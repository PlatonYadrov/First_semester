# [First_contest](https://github.com/PlatonYadrov/First_semester/tree/main/first_contest)
## [A. Жизнь в квадрате](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/A.cpp "Задача A")
В некоторых клетках квадрата N×N живут микроорганизмы (не более одного в одной клетке). Каждую секунду происходит следующее: -- все микроорганизмы, у которых менее 2-х соседей, умирают от скуки (соседями называются микроорганизмы, живущие в клетках, имеющих общую сторону или вершину); -- все микроорганизмы, у которых более 3-х соседей, умирают от перенаселенности; -- на всех пустых клетках, у которых ровно в трех соседних клетках жили микроорганизмы, появляются новые микроорганизмы. Все изменения происходят одновременно, то есть для каждой клетки сначала выясняется ее судьба, а затем происходят изменения сразу во всех клетках. Требуется по данной конфигурации определить, во что она превратится через T секунд.
### Формат ввода
В первой строке вводятся два натуральных числа -- N (1 ≤ N ≤ 10) и T (1 ≤ T ≤ 100). Далее записано N строчек по N чисел, описывающих начальную конфигурацию (0 -- пустая клетка, 1 -- микроорганизм). Числа в строках разделены пробелами.
### Формат вывода
Требуется вывести N строк по N чисел -- описание конфигурации через T секунд (в том же формате, как и во входных данных).
## [B. Тетрадка](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/B.cpp)
Проектная работа Виталика по компьютерному зрению заключается в распознавании типа тетрадки по небольшому ее участку (в клетку, в линейку, в вертикальную линейку). Однако времени обучать нейросеть у Виталика нет, поэтому он попросил вас помочь ему написать программу на C++, которая бы делала это без привлечения искусственного интеллекта (почему вы согласились на это, и почему эта задача обязательна, легенда умалчивает).  
Часть тетрадки представляет собой двумерную таблицу из нулей и единиц, где единица — закрашенный участок, а нуль — незакрашенный. Вертикальной линией считается столбец, в котором стоят только единицы, горизонтальной — строка, второй стоят только единицы. Гарантируется, что тетрадь изначально пустая, то есть единица обязательно является частью какой-то линии.  
Тетрадь в горизонтальную линейку состоит только из горизонтальных линий, в вертикальную линейку — только из вертикальных линий, в клетку — из линий обоих типов. Причем расстояния между всеми параллельными линиями одинаковы (клетки - обязательно квадраты), и между ними обязательно есть пустоты (не могут располагаться вплотную).  
По заданному участку выведите тип тетради, если его возможно однозначно определить.
### Формат ввода
В первой строке даны целые числа n и m (1 ≤ n, m ≤ 1 000) — количество строк и столбцов в видимом участке. Далле следует n строк по m целых чисел a<sub>i,j</sub> (0 ≤ a<sub>i,j</sub> ≤ 1) — видимый участок тетради.
### Формат вывода
В качестве ответа выведите:  
«Square», если тетрадка в клетку; «Line», если тетрадка в линейку; «Vertical line», если тетрадка в вертикальную линейку; «?», если невозможно однозначно определить, к какому типу относится данная тетрадь.
## [C. Мирные ферзи](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/C.cpp)
Дано число N. Определите, сколькими способами можно расставить на доске N × N N ферзей, не бьющих друг друга.
### Формат ввода
Задано единственное число N, N ≤ 10.
### Формат вывода
Необходимо вывести количество способов, которыми можно расставить на доске N × N N ферзей, не бьющих друг друга.
## [D. Фишки](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/D.cpp)
Дана полоска из клеток, пронумерованных от 1 до N. На каждом ходе разрешено поставить фишку на клетку (если её там еще нет) или снять фишку с клетки (если она там есть). При любом действии (постановка фишки или снятие фишки), можно выбрать не любую клетку, а только клетку под номером 1 или клетку, следующую за самой первой фишкой. Изначально полоска пуста. Требуется занять все клетки. Как только все клетки заполнены - действия прекращаются.
### Формат ввода
С клавиатуры вводится натуральное число N (1 ≤ N ≤ 10).
### Формат вывода
Требуется вывести последовательность номеров клеток, с которыми совершается действие в строку через пробел. Если фишка снимается, то номер клетки должен выводиться со знаком минус. Количество действий не должно превышать 10<sup>4</sup>. Если существует несколько возможных решений задачи, то разрешается вывести любое.
## [E. Монетки](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/E.cpp)
В Волшебной стране используются монетки достоинством A<sub>1</sub>, A<sub>2</sub>,..., A<sub>M</sub>. Волшебный человечек пришел в магазин и обнаружил, что у него есть ровно по две монетки каждого достоинства. Ему нужно заплатить сумму N. Напишите программу, определяющую, сможет ли он расплатиться без сдачи.
### Формат ввода
На вход программы сначала поступает число N (1 ≤ N ≤ 10<sup>9</sup>), затем - число M (1 ≤ M ≤ 15) и далее M попарно различных чисел A<sub>1</sub>, A<sub>2</sub>,..., A<sub>M</sub> (1 ≤ A<sub>i</sub> ≤ 10<sup>9</sup>).
### Формат вывода
Сначала выведите K - количество монет, которое придется отдать Волшебному человечку, если он сможет заплатить указанную сумму без сдачи. Далее выведите K чисел, задающих достоинства монет. Если решений несколько, выведите вариант, в котором Волшебный человек отдаст наименьшее возможное количество монет. Если таких вариантов несколько, выведите любой из них.  
Если без сдачи не обойтись, то выведите одно число 0. Если же у Волшебного человечка не хватит денег, чтобы заплатить указанную сумму, выведите одно число -1 (минус один).
## [F. Ханойские башни](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/F.cpp)
Головоломка "Ханойские башни" состоит из трех стержней, пронумерованных числами 1, 2, 3. На стержень 1 надета пирамидка из n дисков различного диаметра в порядке возрастания диаметра. Диски можно перекладывать с одного стержня на другой по одному, при этом диск нельзя класть на диск меньшего диаметра. Необходимо переложить всю пирамидку со стержня 1 на стержень 3 за минимальное число перекладываний.  
Напишите программу, которая решает головоломку; для данного числа дисков n печатает последовательность перекладываний в формате a, b, c, где a — номер перекладываемого диска, b — номер стержня с которого снимается данный диск, c — номер стержня на который надевается данный диск.  
Например, строка 1 2 3 означает перемещение диска номер 1 со стержня 2 на стержень 3. В одной строке печатается одна команда. Диски пронумерованы числами от 1 до n в порядке возрастания диаметров.
### Формат ввода
Вводится натуральное число n (1 ≤ n ≤ 10).
### Формат вывода
Программа должна вывести минимальный (по количеству произведенных операций) способ перекладывания пирамидки из данного числа дисков.
## [G. Несправедливые башни](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/G.cpp)
В Ханое несправедливо запретили класть самый маленький диск (номер 1) на средний колышек (номер 2).  
Решите головоломку с учетом этих ограничений. Вам не нужно находить минимальное решение, но количество совершенных перемещений не должно быть больше 200000, при условии, что количество дисков не превосходит 10.
### Формат ввода
Вводится натуральное число n.
### Формат вывода
Выведите ответ на задачу.
## [H. Данные под защитой](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/H.cpp)
В одной неизвестной соцсети используется следующий алгоритм шифрования сообщений. Каждой букве слова присвается некоторый номер: первой букве - номер 1, последней - номер 2, второй - номер 3, предпоследней - номер 4, и так далее. Далее буквы записываются в порядке следования номеров и в конец приписывается символ '#'.  
Пример: слово «надежность» будет передано как «ньатдсеожн#».  
Вам удалось перехватить одно из сообщений. Напишите программу, которая дешифрует полученное слово.
### Формат ввода
На вход подается шифр из не более 10<sup>5</sup> букв
### Формат вывода
Напечатайте исходное слово
## [I. Работник месяца](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/I.cpp)
Директор предприятия решил поощрять наиболее отличившихся сотрудников и каждый месяц вешать N лучших из них на доску почета. Фотографии каждого из сотрудников представляют собой прямоугольник W × H, а доска по плану директора имеет форму квадрата. Напишите программу, которая по данным W, H и N вычисляет минимальную длину стороны доски, достаточную для размещения всех фотографий. Фотографии на доске не могут быть повернуты, а также пересекаться между собой.
### Формат ввода
На вход подается три целых числа: W, H, N (1 ≤ W, H, N ≤ 10<sup>9</sup>).
### Формат вывода
В выходной файл необходимо вывести ответ на поставленную задачу.
## [J. Палиндром](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/J.cpp)
Палиндромом называется строка, которая, после удаления из нее всех пробелов и знаков препинания, читается одинаково справа налево и слева направо.
По заданной строке нужно определить, можно ли с помощью одного изменения (замены символа, удаления или добавления) превратить ее в палиндром. В палиндроме учитываются только латинские буквы без учета регистра. То есть строки "aba, cA !Ba" и "abacaba" задают один и тот же палиндром.
### Формат ввода
Дана строка s (1 ≤ |s| ≤ 10<sup>5</sup>)
### Формат вывода
Выведите YES, если палиндром получить можно, и NO иначе. В случае ответа YES выведите полученный палиндром.
## [K. Лень - двигатель прогресса](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/K.cpp)
Виталик заметил, что сдача задач по алгоритмам в свою очередь сводится к другому алгоритму, состоящему из небольшого количества уникальных действий (открытие файла, сборка, тестирование, и т.д.). Всего он выявил 26 таких действий и обозначил каждое из них строчной буквой латинского алфавита (вот совпадение!).  
Для оптимизации времени, потраченного на сдачу заданий, Виталик решил написать программу (скрипт), который бы автоматизировал некоторую часть этой рутинной работы. Идея довольно проста: скрипт в цикле выполняет K фиксированных действий подряд, то есть сначала выполняется первое действие, затем второе и т.д. после окончания последнего действия работа скрипта продолжается с первого. При этом скрипт останавливается после фиксированного числа шагов (которое указывает Виталик). Время затраченное на написание скрипта Виталик считает оправданным, если он выполнит хотя бы K + 1 действие. Скрипт может запускаться только один раз.  
По заданной последовательности действий определите количество способов написать "оправданный"скрипт.
### Формат ввода
В первой строке записано число K > 0 — количество действий, которые выполняются в цикле скрипта. Во второй строке записаны N (K < N ≤ 10<sup>6</sup>) строчных латинских букв, обозначающих алгоритм сдачи задания.
### Формат вывода
Выведите ответ на задачу
## [L. Одинаковые элементы](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/L.cpp)
Напишите программу, проверяющую совпадают ли множества уникальных элементов двух массивов.
### Формат ввода
Вводится число N (1 ≤ N ≤ 100000) – размер первого массива. Во второй строке идет N целых чисел, не превосходящих по модулю 10<sup>9</sup> – элементы массива. Далее аналогично задается второй массив.
### Формат вывода
Программа должна вывести слово YES, если множества уникальных элементов совпадают, и слово NO в противном случае.
## [M. Количество инверсий](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/M.cpp)
Напишите программу, которая для заданного массива A=a<sub>1</sub>, a<sub>2</sub>,..., a<sub>n</sub> находит количество пар (i, j) таких , что i < j и a<sub>i</sub> > a<sub>j</sub>.
### Формат ввода
Первая строка входного файла содержит натуральное число n (1 ≤ n ≤ 500000) --- количество элементов массива. Вторая строка содержит n элементов массива A (
0 ≤ a<sub>i</sub> ≤ 10<sup>6</sup>).
### Формат вывода
В выходной файл выведите одно число --- ответ на задачу.
## [N. CString](https://github.com/PlatonYadrov/First_semester/tree/main/first_contest/ctring)
<i>C-style строкой называется последовательность байт (char), ограниченная нулевым символом ('\0'). Работа с C-style строками во многом похожа на работу с массивами, при этом специфичные для строк операции (вычисление длины, конкатенация, сравнение и т.п.) вынесены в отдельную библиотеку функций <cstring>. В этом задании вам предстоит познакомиться с ней подробнее, реализовав собственный аналог.</i>
### Условие задачи
Реализуйте модуль `cstring`, состоящий из следующих функций:
* `size_t Strlen(const char* str)`;. Вычисляет длину строки `str` (без учета нулевого символа).
* `int Strcmp(const char* first, const char* second)`;. Лексикографически сравнивает две строки. Если `first < second`, то возвращает произвольное отрицательное число, если `first > second`, то - положительное. В случае равенства возвращает 0.
* `int Strncmp(const char* first, const char* second, size_t count)`;. То же, что и предыдущая функция, но сравнивает первые count символов строк (либо пока не встретит нулевой символ).
* `char* Strcpy(char* dest, const char* src)`;. Принимает строку src и копирует ее содержимое (вместе с нуль-терминатором) в `dest`. Гарантируется, что `dest` указывает на область памяти, достаточную для хранения `src`. Возвращает `dest`.
* `char* Strncpy(char* dest, const char* src, size_t count)`;. То же, что и предыдущая функция, но копирует ровно count символов из `src`. Если `count` больше размера `src`, то оставшиеся символы заполняются нуль-символами. Возвращает `dest`.
* `char* Strcat(char* dest, const char* src)`;. Приписывает строку src в конец строки `dest` (конкатенация строк). Гарантируется, что `dest` указывает на область памяти, достаточную для хранения итоговой строки. Возвращает `dest`.
* `char* Strncat(char* dest, const char* src, size_t count)`;. То же, что и предыдущая функция, но добавляет только первые `count` символов из `src` + нулевой символ. Если count больше чем длина `src`, то работает так же как и `Strcat(dest, src)`. Возвращает `dest`.
* `const char* Strchr(const char* str, char symbol)`;. Возвращает указатель на первое появление символа `symbol` в строке `str` (с учетом нулевого символа), либо нулевой указатель, если такого символа нет.
* `const char* Strrchr(const char* str, char symbol)`;. Возвращает указатель на последнее появление символа `symbol` в строке `str` (с учетом нулевого символа), либо нулевой указатель, если такого символа нет.
* `size_t Strspn(const char* dest, const char* src)`;. Возвращает количество первых символов `dest`, которые встречаются в строке `src` (без учета нулевого символа).
* `size_t Strcspn(const char* dest, const char* src)`;. Возвращает количество первых символов `dest`, которые не встречаются в строке `src` (без учета нулевого символа).
* `const char* Strpbrk(const char* dest, const char* breakset)`;. Возвращает указатель на первый элемент `dest`, который лежит в `breakset`, либо нулевой указатель, если такого элемента нет.
* `const char* Strstr(const char* str, const char* pattern)`;. Осуществляет поиск подстроки `pattern` в строке `str`. Возвращает указатель на начало первого вхождения, либо нулевой указатель, если вхождения найдено не было.  
При необходимости подробнее про работу функций можете прочитать на странице [https://cplusplus.com/reference/cstring/](https://cplusplus.com/reference/cstring/) . Использовать функции `memcpy`, `memcmp` и подобные запрещено.  
В качестве решения от вас ожидается модуль, состоящий из 2х файлов: `cstring.h` и `cstring.cpp`. Файлы присылайте в виде ZIP-архива.  
Присланный модуль будет собран вместе с файлом с тестами на сервере, `main` присылать не нужно. Интерфейс функций должен в точности совпадать с тем, что описан в условии (тесты ожидают именно его), в противном случае вы получите ошибку компиляции.  
При ошибке в реализации вы получите вердикт RE. В нем будет указана функция, которая требует исправлений.
## [O. Бинпоиск. Шаблоны](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/O.cpp)
Пришлите заголовочный файл с определениями трех шаблонных функций для работы с отсортированными последовательностями. Каждая функция принимает три аргумента: _begin_ - указатель на начало последовательности, _end_ - указатель на конец последовательности (элемент следующий за последним), _value_ - запрос.  
* __BinarySearch:__
функция, осуществляющая проверку наличия элемента _value_ в отсортированной последовательности _[begin,end)_. Возвращает _true_, если и только если на полуинтервале _[begin,end)_ имеется значение _value_.
* __LowerBound:__
функция, осуществляющая поиск первого элемента не меньшего (≥) _value_ на полуинтервале _[begin,end)_. Возвращает указатель на найденный элемент, либо _end_, если такого нет.
* __UpperBound:__
функция, осуществляющая поиск первого элемента строго большего (>) _value_ на полуинтервале _[begin,end)_. Возвращает указатель на найденный элемент, либо _end_, если такого нет.  
__Важно__: используйте только сравнение на меньше (<) и избегайте лишних копирований элементов. То есть считайте, что элементы последовательности не копируемы и могут быть сравнены только с помощью операции <.
### Формат ввода:
__Данная информация нужна только для понимания примера. Обработку пользовательского ввода писать не нужно. Вместо указателей в примере вводятся и выводятся индексы элементов.__  
На первой строчке подается число элементов в последовательности, а далее сами элементы.  
В следующих строках следует число запросов и сами запросы в формате (_begin, end, value_).  
### Формат вывода:
__Данная информация нужна только для понимания примера. Ваши функции ничего выводить не должны.__  
Выводятся 3 числа - результаты вызова _BinarySearch, LowerBound и UpperBound_ соответственно.
## [P. Слияние. Шаблоны](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/P.cpp)
Реализуйте шаблонную функцию `Merge`, которая принимает две отсортированные последовательности и сливает их одну большую отсортированную.  
Функция должна принимать 5 аргументов: `first_begin, first_end` - указатели на начало и конец первой последовательности; `second_begin, second_end` - начало и конец второй последовательности; `out` - указатель на начало итоговой последовательности (куда записывать ответ).  
Последовательности `first, second` и out могут хранить значения разных типов!  
__Ваш код будет проверяться на скрытых от вас юнит-тестах, проверяющих корректность шаблонной реализации. Требование к реализации: из операций сравнения можно использовать только операцию "<".  
Пришлите на проверку заголовочный файл, содержащий ТОЛЬКО определение шаблона. Он будет включен в cpp файл с тестами автоматически (main писать не нужно!).__
## [Q. Сортировка. Шаблоны](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/Q.cpp)
В данной задаче вам необходимо реализовать шаблонную функцию `Sort`, сортирующую переданную последовательность. Функция должна принимать два аргумента: `begin` - указатель на начало последовательности, `end` - указатель на конец последовательности (элемент следующий за последним).  
__Ваш код будет проверяться на скрытых от вас юнит-тестах, проверяющих корректность шаблонной реализации. Требование к реализации: из операций сравнения можно использовать только операцию "<".  
Пришлите на проверку заголовочный файл, содержащий ТОЛЬКО определение шаблона. Он будет включен в cpp файл с тестами автоматически (main писать не нужно!).__
## [R. k-я порядковая статистика. Шаблоны](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/R.cpp)
Реализуйте шаблонную функцию _KthElement_, которая упорядочивает элементы последовательности так, чтобы на k-м месте (в 0 индексации) стоял k-й по величине элемент последовательности.  
Функция должна принимать 3 аргумента: `begin` - указатель на начало последовательности; `kth` - указатель на k-ю позицию; `end` - указатель на конец последовательности.  
Среднее время работы алгоритма должно быть линейным от длины полуинтервала `[begin, end)`.  
__Ваш код будет проверяться на скрытых от вас юнит-тестах, проверяющих корректность шаблонной реализации. Требование к реализации: из операций сравнения можно использовать только операцию "<".  
Пришлите на проверку заголовочный файл, содержащий ТОЛЬКО определение шаблона. Он будет включен в cpp файл с тестами автоматически (main писать не нужно!).__
## [S. Приоритетная очередь. Шаблоны](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/S.cpp)
В данной задаче вам необходимо реализовать шаблонные функции для работы с бинарной пирамидой (с максимумом на вершине):  
__PushHeap__ - восстанавливает пирамиду после добавления нового элемента (`Insert`);  
__PopHeap__ - восстанавливает пирамиду после извлечения максимального элемента из пирамиды.  
Функция `PushHeap` должна принимать два аргумента: `begin` - указатель на начало последовательности, `end` - указатель на конец последовательности (элемент следующий за последним). Поведение, ожидающееся от функции: вставляет в пирамиду элемент, находящийся на позиции `end - 1`, восстанавливает пирамиду на диапазоне `[begin, end)`. Гарантируется, что перед выполнением функции `PushHeap` диапазон `[begin, end - 1)` является корректной пирамидой.  
Функция `PopHeap` должна принимать два аргумента: `begin` - указатель на начало последовательности, `end` - указатель на конец последовательности (элемент следующий за последним). Поведение, ожидающееся от функции: меняет местами элемент на позиции `begin` с элементом на позиции `end - 1` и восстанавливает пирамиду на диапазоне `[begin, end - 1)`. Гарантируется, что перед выполнением функции `PopHeap` диапазон `[begin, end)` является корректной пирамидой.  
__Ваш код будет проверяться на скрытых от вас юнит-тестах, проверяющих корректность шаблонной реализации. Требование к реализации: из операций сравнения можно использовать только операцию "<".  
Пришлите на проверку заголовочный файл, содержащий ТОЛЬКО определение шаблона. Он будет включен в cpp файл с тестами автоматически (main писать не нужно!).__
## [T. Нужно больше слияний!](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/T.cpp)
Дано K отсортированных массивов с суммарной длиной N. Слейте их в один большой отсортированный массив размера N. Решение должно работать асимптотически быстрее чем &#937; (NlogN) в худшем случае.
### Формат ввода:
В первой строке идет число K (1 ≤ K ≤ 10<sup>6</sup>). Далее идет K блоков — описания массивов для слияния в следующем формате.  
На первой строке идет число N<sub>i</sub> — размер i-го массива. На второй строке через пробел идут N<sub>i</sub> целых чисел, не превосходящих по модулю 10<sup>9</sup>.  
### Формат вывода:
Выведите N целых чисел в порядке неубывания — массив, полученный в результате слияния K отсортированных массивов.
## [U. Бинаризуй меня](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/U.cpp)
Дана строка. Требуется заменить все числа в ней на двоичные аналоги (перевести из десятичной в двоичную систему счисления).
### Формат ввода:
На вход подается строка из не более 255 символов, среди которых могут быть и пробельные. Гарантируется, что числа в строке не начинаются с 0.
### Формат вывода:
Выведите результат
## [V. Эчпочмак](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/V.cpp)
Из трех отрезков можно составить треугольник, если длина каждого из них не превосходит суммы длин двух других (да, вырожденный треугольник в этой задаче считается треугольником).  
Дан набор из N отрезков. Необходимо выбрать подмножество отрезков с наибольшей суммарной длиной, в котором любые три отрезка могут образовать треугольник.
### Формат ввода:
Вводится число N (1 ≤ N ≤ 30000). В следующих N строках записаны целые числа L<sub>i</sub> (0 ≤ L<sub>i</sub> ≤ 60000), задающие длины отрезков.
### Формат вывода:
Выведите размер найденного множества и суммарную длину отрезков в нем
## [W. Абитуриенты](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/W.cpp)
В ВУЗ поступает N человек. Приемная комиссия хочет набрать M групп по K человек. Главным критерием набора студентов в группы является комфортность обучения в каждой из них. Считается, что чем выше размах (разность между наибольшим и наименьшим значениями) баллов ЕГЭ внутри группы, тем она менее комфортна для обучения.  
Необходимо составить группы так, чтобы максимальное значение размаха в баллах среди них было минимально (чтобы наиболее некомфортная группа была как можно более комфортной).
### Формат ввода:
Вводятся числа N, M и K (1 ≤ M ⋅ K ≤ N ≤ 10<sup>5</sup>). Далее идут N целых чисел --- балл ЕГЭ каждого из абитуриентов. С учетом индивидуальных достижений балл абитуриента не превосходит 10<sup>9</sup>.
### Формат вывода:
Выведите одно число --- наименьшее возможное значение максимального размаха.
## [Y. Простая задачка](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/Y.cpp)
### Формат ввода:
На взод подаются 6 строк длины 20. Входные данные содержат 6 строк по 20 символов. Каждый прямоугольник 6x5 задает цифру циферблата.
### Формат вывода:
Выведите время в формате hh:mm. Если время нельзя определить однозначно, выведите AMBIGUITY. Если же в часах точно сломалось еще что-то, например, неправильный формат времени, либо отображаются лишние пиксели, выведите ERROR.
## [Z. Пиксель-арт](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/Z.cpp)
Дана таблица размера N × M, каждая клетка которой раскрашена в один из K цветов. Цвета пронумерованы числами от 0 до K − 1. Клетка, стоящая в i-й строке и j-м столбце имеет цвет (i + j) % K. Строки и столбцы нумеруются с 0.  
Для каждого цвета укажите, сколько раз он встречается в таблице.
### Формат ввода:
Вводятся числа N, M, K (1 ≤ N, M ≤ 10<sup>9</sup>, 1 ≤ K ≤ 2 ⋅ 10<sup>5</sup>) — размеры таблицы и количество цветов соответственно.
### Формат вывода:
Выведите через пробел K целых чисел, где i-е число обозначает количество клеток, покрашенных в i-й цвет (i от 0 до K − 1).
# [Second_contest](https://github.com/PlatonYadrov/First_semester/tree/main/second_contest)
## [A. Приемная кампания](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/A.cpp)
Ваша цель — реализовать стабильную сортировку для следующей задачи.  
Выведите фамилии и имена абитуриентов, подавших документы на поступление на ПМИ ФПМИ в порядке убывания их среднего балла по ЕГЭ.  
Про каждого ученика известны их фамилии, имена и баллы ЕГЭ по следующим предметам: информатика, математика и русский язык.
### Формат ввода:
В первой строке идет число N (1 ≤ N ≤ 10<sup>5</sup>) — количество абитуриентов, подавших документы.  
Далее идет N строк — описания ученика в формате «surname name inf_points math_points rus_points», где «surname» и «name» — строки длины не более 40, а «*_points» — баллы за экзамены (целые числа от нуля до ста включительно).
### Формат вывода:
Необходимо вывести пары фамилия-имя по одной на строке, разделяя фамилию и имя одним пробелом. Выводить баллы не нужно. Если несколько учащихся имеют одинаковые средние баллы, то их нужно выводить в порядке, заданном во входных данных.
