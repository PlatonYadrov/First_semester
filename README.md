# [First_contest](https://github.com/PlatonYadrov/First_semester/tree/main/first_contest)
## [A. Жизнь в квадрате](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/A.cpp "Задача A")
В некоторых клетках квадрата N×N живут микроорганизмы (не более одного в одной клетке). Каждую секунду происходит следующее: -- все микроорганизмы, у которых менее 2-х соседей, умирают от скуки (соседями называются микроорганизмы, живущие в клетках, имеющих общую сторону или вершину); -- все микроорганизмы, у которых более 3-х соседей, умирают от перенаселенности; -- на всех пустых клетках, у которых ровно в трех соседних клетках жили микроорганизмы, появляются новые микроорганизмы. Все изменения происходят одновременно, то есть для каждой клетки сначала выясняется ее судьба, а затем происходят изменения сразу во всех клетках. Требуется по данной конфигурации определить, во что она превратится через T секунд.
### Формат ввода
В первой строке вводятся два натуральных числа -- N (1 ≤ N ≤ 10) и T (1 ≤ T ≤ 100). Далее записано N строчек по N чисел, описывающих начальную конфигурацию (0 -- пустая клетка, 1 -- микроорганизм). Числа в строках разделены пробелами.
### Формат вывода
Требуется вывести N строк по N чисел -- описание конфигурации через T секунд (в том же формате, как и во входных данных).
## [B. Тетрадка](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/B.cpp)
Проектная работа Виталика по компьютерному зрению заключается в распознавании типа тетрадки по небольшому ее участку (в клетку, в линейку, в вертикальную линейку). Однако времени обучать нейросеть у Виталика нет, поэтому он попросил вас помочь ему написать программу на C++, которая бы делала это без привлечения искусственного интеллекта (почему вы согласились на это, и почему эта задача обязательна, легенда умалчивает).  
Часть тетрадки представляет собой двумерную таблицу из нулей и единиц, где единица — закрашенный участок, а нуль — незакрашенный. Вертикальной линией считается столбец, в котором стоят только единицы, горизонтальной — строка, второй стоят только единицы. Гарантируется, что тетрадь изначально пустая, то есть единица обязательно является частью какой-то линии.  
Тетрадь в горизонтальную линейку состоит только из горизонтальных линий, в вертикальную линейку — только из вертикальных линий, в клетку — из линий обоих типов. Причем расстояния между всеми параллельными линиями одинаковы (клетки - обязательно квадраты), и между ними обязательно есть пустоты (не могут располагаться вплотную).  
По заданному участку выведите тип тетради, если его возможно однозначно определить.
### Формат ввода
В первой строке даны целые числа n и m (1 ≤ n, m ≤ 1 000) — количество строк и столбцов в видимом участке. Далле следует n строк по m целых чисел a<sub>i,j</sub> (0 ≤ a<sub>i,j</sub> ≤ 1) — видимый участок тетради.
### Формат вывода
В качестве ответа выведите:  
«Square», если тетрадка в клетку; «Line», если тетрадка в линейку; «Vertical line», если тетрадка в вертикальную линейку; «?», если невозможно однозначно определить, к какому типу относится данная тетрадь.
## [C. Мирные ферзи](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/C.cpp)
Дано число N. Определите, сколькими способами можно расставить на доске N × N N ферзей, не бьющих друг друга.
### Формат ввода
Задано единственное число N, N ≤ 10.
### Формат вывода
Необходимо вывести количество способов, которыми можно расставить на доске N × N N ферзей, не бьющих друг друга.
## [D. Фишки](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/D.cpp)
Дана полоска из клеток, пронумерованных от 1 до N. На каждом ходе разрешено поставить фишку на клетку (если её там еще нет) или снять фишку с клетки (если она там есть). При любом действии (постановка фишки или снятие фишки), можно выбрать не любую клетку, а только клетку под номером 1 или клетку, следующую за самой первой фишкой. Изначально полоска пуста. Требуется занять все клетки. Как только все клетки заполнены - действия прекращаются.
### Формат ввода
С клавиатуры вводится натуральное число N (1 ≤ N ≤ 10).
### Формат вывода
Требуется вывести последовательность номеров клеток, с которыми совершается действие в строку через пробел. Если фишка снимается, то номер клетки должен выводиться со знаком минус. Количество действий не должно превышать 10<sup>4</sup>. Если существует несколько возможных решений задачи, то разрешается вывести любое.
## [E. Монетки](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/E.cpp)
В Волшебной стране используются монетки достоинством A<sub>1</sub>, A<sub>2</sub>,..., A<sub>M</sub>. Волшебный человечек пришел в магазин и обнаружил, что у него есть ровно по две монетки каждого достоинства. Ему нужно заплатить сумму N. Напишите программу, определяющую, сможет ли он расплатиться без сдачи.
### Формат ввода
На вход программы сначала поступает число N (1 ≤ N ≤ 10<sup>9</sup>), затем - число M (1 ≤ M ≤ 15) и далее M попарно различных чисел A<sub>1</sub>, A<sub>2</sub>,..., A<sub>M</sub> (1 ≤ A<sub>i</sub> ≤ 10<sup>9</sup>).
### Формат вывода
Сначала выведите K - количество монет, которое придется отдать Волшебному человечку, если он сможет заплатить указанную сумму без сдачи. Далее выведите K чисел, задающих достоинства монет. Если решений несколько, выведите вариант, в котором Волшебный человек отдаст наименьшее возможное количество монет. Если таких вариантов несколько, выведите любой из них.  
Если без сдачи не обойтись, то выведите одно число 0. Если же у Волшебного человечка не хватит денег, чтобы заплатить указанную сумму, выведите одно число -1 (минус один).
## [F. Ханойские башни](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/F.cpp)
Головоломка "Ханойские башни" состоит из трех стержней, пронумерованных числами 1, 2, 3. На стержень 1 надета пирамидка из n дисков различного диаметра в порядке возрастания диаметра. Диски можно перекладывать с одного стержня на другой по одному, при этом диск нельзя класть на диск меньшего диаметра. Необходимо переложить всю пирамидку со стержня 1 на стержень 3 за минимальное число перекладываний.  
Напишите программу, которая решает головоломку; для данного числа дисков n печатает последовательность перекладываний в формате a, b, c, где a — номер перекладываемого диска, b — номер стержня с которого снимается данный диск, c — номер стержня на который надевается данный диск.  
Например, строка 1 2 3 означает перемещение диска номер 1 со стержня 2 на стержень 3. В одной строке печатается одна команда. Диски пронумерованы числами от 1 до n в порядке возрастания диаметров.
### Формат ввода
Вводится натуральное число n (1 ≤ n ≤ 10).
### Формат вывода
Программа должна вывести минимальный (по количеству произведенных операций) способ перекладывания пирамидки из данного числа дисков.
## [G. Несправедливые башни](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/G.cpp)
В Ханое несправедливо запретили класть самый маленький диск (номер 1) на средний колышек (номер 2).  
Решите головоломку с учетом этих ограничений. Вам не нужно находить минимальное решение, но количество совершенных перемещений не должно быть больше 200000, при условии, что количество дисков не превосходит 10.
### Формат ввода
Вводится натуральное число n.
### Формат вывода
Выведите ответ на задачу.
## [H. Данные под защитой](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/H.cpp)
В одной неизвестной соцсети используется следующий алгоритм шифрования сообщений. Каждой букве слова присвается некоторый номер: первой букве - номер 1, последней - номер 2, второй - номер 3, предпоследней - номер 4, и так далее. Далее буквы записываются в порядке следования номеров и в конец приписывается символ '#'.  
Пример: слово «надежность» будет передано как «ньатдсеожн#».  
Вам удалось перехватить одно из сообщений. Напишите программу, которая дешифрует полученное слово.
### Формат ввода
На вход подается шифр из не более 10<sup>5</sup> букв
### Формат вывода
Напечатайте исходное слово
## [I. Работник месяца](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/I.cpp)
Директор предприятия решил поощрять наиболее отличившихся сотрудников и каждый месяц вешать N лучших из них на доску почета. Фотографии каждого из сотрудников представляют собой прямоугольник W × H, а доска по плану директора имеет форму квадрата. Напишите программу, которая по данным W, H и N вычисляет минимальную длину стороны доски, достаточную для размещения всех фотографий. Фотографии на доске не могут быть повернуты, а также пересекаться между собой.
### Формат ввода
На вход подается три целых числа: W, H, N (1 ≤ W, H, N ≤ 10<sup>9</sup>).
### Формат вывода
В выходной файл необходимо вывести ответ на поставленную задачу.
## [J. Палиндром](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/J.cpp)
Палиндромом называется строка, которая, после удаления из нее всех пробелов и знаков препинания, читается одинаково справа налево и слева направо.
По заданной строке нужно определить, можно ли с помощью одного изменения (замены символа, удаления или добавления) превратить ее в палиндром. В палиндроме учитываются только латинские буквы без учета регистра. То есть строки "aba, cA !Ba" и "abacaba" задают один и тот же палиндром.
### Формат ввода
Дана строка s (1 ≤ |s| ≤ 10<sup>5</sup>)
### Формат вывода
Выведите YES, если палиндром получить можно, и NO иначе. В случае ответа YES выведите полученный палиндром.
## [K. Лень - двигатель прогресса](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/K.cpp)
Виталик заметил, что сдача задач по алгоритмам в свою очередь сводится к другому алгоритму, состоящему из небольшого количества уникальных действий (открытие файла, сборка, тестирование, и т.д.). Всего он выявил 26 таких действий и обозначил каждое из них строчной буквой латинского алфавита (вот совпадение!).  
Для оптимизации времени, потраченного на сдачу заданий, Виталик решил написать программу (скрипт), который бы автоматизировал некоторую часть этой рутинной работы. Идея довольно проста: скрипт в цикле выполняет K фиксированных действий подряд, то есть сначала выполняется первое действие, затем второе и т.д. после окончания последнего действия работа скрипта продолжается с первого. При этом скрипт останавливается после фиксированного числа шагов (которое указывает Виталик). Время затраченное на написание скрипта Виталик считает оправданным, если он выполнит хотя бы K + 1 действие. Скрипт может запускаться только один раз.  
По заданной последовательности действий определите количество способов написать "оправданный"скрипт.
### Формат ввода
В первой строке записано число K > 0 — количество действий, которые выполняются в цикле скрипта. Во второй строке записаны N (K < N ≤ 10<sup>6</sup>) строчных латинских букв, обозначающих алгоритм сдачи задания.
### Формат вывода
Выведите ответ на задачу
## [L. Одинаковые элементы](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/L.cpp)
Напишите программу, проверяющую совпадают ли множества уникальных элементов двух массивов.
### Формат ввода
Вводится число N (1 ≤ N ≤ 100000) – размер первого массива. Во второй строке идет N целых чисел, не превосходящих по модулю 10<sup>9</sup> – элементы массива. Далее аналогично задается второй массив.
### Формат вывода
Программа должна вывести слово YES, если множества уникальных элементов совпадают, и слово NO в противном случае.
## [M. Количество инверсий](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/M.cpp)
Напишите программу, которая для заданного массива A=a<sub>1</sub>, a<sub>2</sub>,..., a<sub>n</sub> находит количество пар (i, j) таких , что i < j и a<sub>i</sub> > a<sub>j</sub>.
### Формат ввода
Первая строка входного файла содержит натуральное число n (1 ≤ n ≤ 500000) --- количество элементов массива. Вторая строка содержит n элементов массива A (
0 ≤ a<sub>i</sub> ≤ 10<sup>6</sup>).
### Формат вывода
В выходной файл выведите одно число --- ответ на задачу.
## [N. CString](https://github.com/PlatonYadrov/First_semester/tree/main/first_contest/ctring)
<i>C-style строкой называется последовательность байт (char), ограниченная нулевым символом ('\0'). Работа с C-style строками во многом похожа на работу с массивами, при этом специфичные для строк операции (вычисление длины, конкатенация, сравнение и т.п.) вынесены в отдельную библиотеку функций <cstring>. В этом задании вам предстоит познакомиться с ней подробнее, реализовав собственный аналог.</i>
### Условие задачи
Реализуйте модуль `cstring`, состоящий из следующих функций:
* `size_t Strlen(const char* str)`;. Вычисляет длину строки `str` (без учета нулевого символа).
* `int Strcmp(const char* first, const char* second)`;. Лексикографически сравнивает две строки. Если `first < second`, то возвращает произвольное отрицательное число, если `first > second`, то - положительное. В случае равенства возвращает 0.
* `int Strncmp(const char* first, const char* second, size_t count)`;. То же, что и предыдущая функция, но сравнивает первые count символов строк (либо пока не встретит нулевой символ).
* `char* Strcpy(char* dest, const char* src)`;. Принимает строку src и копирует ее содержимое (вместе с нуль-терминатором) в `dest`. Гарантируется, что `dest` указывает на область памяти, достаточную для хранения `src`. Возвращает `dest`.
* `char* Strncpy(char* dest, const char* src, size_t count)`;. То же, что и предыдущая функция, но копирует ровно count символов из `src`. Если `count` больше размера `src`, то оставшиеся символы заполняются нуль-символами. Возвращает `dest`.
* `char* Strcat(char* dest, const char* src)`;. Приписывает строку src в конец строки `dest` (конкатенация строк). Гарантируется, что `dest` указывает на область памяти, достаточную для хранения итоговой строки. Возвращает `dest`.
* `char* Strncat(char* dest, const char* src, size_t count)`;. То же, что и предыдущая функция, но добавляет только первые `count` символов из `src` + нулевой символ. Если count больше чем длина `src`, то работает так же как и `Strcat(dest, src)`. Возвращает `dest`.
* `const char* Strchr(const char* str, char symbol)`;. Возвращает указатель на первое появление символа `symbol` в строке `str` (с учетом нулевого символа), либо нулевой указатель, если такого символа нет.
* `const char* Strrchr(const char* str, char symbol)`;. Возвращает указатель на последнее появление символа `symbol` в строке `str` (с учетом нулевого символа), либо нулевой указатель, если такого символа нет.
* `size_t Strspn(const char* dest, const char* src)`;. Возвращает количество первых символов `dest`, которые встречаются в строке `src` (без учета нулевого символа).
* `size_t Strcspn(const char* dest, const char* src)`;. Возвращает количество первых символов `dest`, которые не встречаются в строке `src` (без учета нулевого символа).
* `const char* Strpbrk(const char* dest, const char* breakset)`;. Возвращает указатель на первый элемент `dest`, который лежит в `breakset`, либо нулевой указатель, если такого элемента нет.
* `const char* Strstr(const char* str, const char* pattern)`;. Осуществляет поиск подстроки `pattern` в строке `str`. Возвращает указатель на начало первого вхождения, либо нулевой указатель, если вхождения найдено не было.  
При необходимости подробнее про работу функций можете прочитать на странице [https://cplusplus.com/reference/cstring/](https://cplusplus.com/reference/cstring/) . Использовать функции `memcpy`, `memcmp` и подобные запрещено.  
В качестве решения от вас ожидается модуль, состоящий из 2х файлов: `cstring.h` и `cstring.cpp`. Файлы присылайте в виде ZIP-архива.  
Присланный модуль будет собран вместе с файлом с тестами на сервере, `main` присылать не нужно. Интерфейс функций должен в точности совпадать с тем, что описан в условии (тесты ожидают именно его), в противном случае вы получите ошибку компиляции.  
При ошибке в реализации вы получите вердикт RE. В нем будет указана функция, которая требует исправлений.
## [O. Бинпоиск. Шаблоны](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/O.cpp)
Пришлите заголовочный файл с определениями трех шаблонных функций для работы с отсортированными последовательностями. Каждая функция принимает три аргумента: _begin_ - указатель на начало последовательности, _end_ - указатель на конец последовательности (элемент следующий за последним), _value_ - запрос.  
* __BinarySearch:__
функция, осуществляющая проверку наличия элемента _value_ в отсортированной последовательности _[begin,end)_. Возвращает _true_, если и только если на полуинтервале _[begin,end)_ имеется значение _value_.
* __LowerBound:__
функция, осуществляющая поиск первого элемента не меньшего (≥) _value_ на полуинтервале _[begin,end)_. Возвращает указатель на найденный элемент, либо _end_, если такого нет.
* __UpperBound:__
функция, осуществляющая поиск первого элемента строго большего (>) _value_ на полуинтервале _[begin,end)_. Возвращает указатель на найденный элемент, либо _end_, если такого нет.  
__Важно__: используйте только сравнение на меньше (<) и избегайте лишних копирований элементов. То есть считайте, что элементы последовательности не копируемы и могут быть сравнены только с помощью операции <.
### Формат ввода:
__Данная информация нужна только для понимания примера. Обработку пользовательского ввода писать не нужно. Вместо указателей в примере вводятся и выводятся индексы элементов.__  
На первой строчке подается число элементов в последовательности, а далее сами элементы.  
В следующих строках следует число запросов и сами запросы в формате (_begin, end, value_).  
### Формат вывода:
__Данная информация нужна только для понимания примера. Ваши функции ничего выводить не должны.__  
Выводятся 3 числа - результаты вызова _BinarySearch, LowerBound и UpperBound_ соответственно.
## [P. Слияние. Шаблоны](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/P.cpp)
Реализуйте шаблонную функцию `Merge`, которая принимает две отсортированные последовательности и сливает их одну большую отсортированную.  
Функция должна принимать 5 аргументов: `first_begin, first_end` - указатели на начало и конец первой последовательности; `second_begin, second_end` - начало и конец второй последовательности; `out` - указатель на начало итоговой последовательности (куда записывать ответ).  
Последовательности `first, second` и out могут хранить значения разных типов!  
__Ваш код будет проверяться на скрытых от вас юнит-тестах, проверяющих корректность шаблонной реализации. Требование к реализации: из операций сравнения можно использовать только операцию "<".  
Пришлите на проверку заголовочный файл, содержащий ТОЛЬКО определение шаблона. Он будет включен в cpp файл с тестами автоматически (main писать не нужно!).__
## [Q. Сортировка. Шаблоны](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/Q.cpp)
В данной задаче вам необходимо реализовать шаблонную функцию `Sort`, сортирующую переданную последовательность. Функция должна принимать два аргумента: `begin` - указатель на начало последовательности, `end` - указатель на конец последовательности (элемент следующий за последним).  
__Ваш код будет проверяться на скрытых от вас юнит-тестах, проверяющих корректность шаблонной реализации. Требование к реализации: из операций сравнения можно использовать только операцию "<".  
Пришлите на проверку заголовочный файл, содержащий ТОЛЬКО определение шаблона. Он будет включен в cpp файл с тестами автоматически (main писать не нужно!).__
## [R. k-я порядковая статистика. Шаблоны](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/R.cpp)
Реализуйте шаблонную функцию _KthElement_, которая упорядочивает элементы последовательности так, чтобы на k-м месте (в 0 индексации) стоял k-й по величине элемент последовательности.  
Функция должна принимать 3 аргумента: `begin` - указатель на начало последовательности; `kth` - указатель на k-ю позицию; `end` - указатель на конец последовательности.  
Среднее время работы алгоритма должно быть линейным от длины полуинтервала `[begin, end)`.  
__Ваш код будет проверяться на скрытых от вас юнит-тестах, проверяющих корректность шаблонной реализации. Требование к реализации: из операций сравнения можно использовать только операцию "<".  
Пришлите на проверку заголовочный файл, содержащий ТОЛЬКО определение шаблона. Он будет включен в cpp файл с тестами автоматически (main писать не нужно!).__
## [S. Приоритетная очередь. Шаблоны](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/S.cpp)
В данной задаче вам необходимо реализовать шаблонные функции для работы с бинарной пирамидой (с максимумом на вершине):  
__PushHeap__ - восстанавливает пирамиду после добавления нового элемента (`Insert`);  
__PopHeap__ - восстанавливает пирамиду после извлечения максимального элемента из пирамиды.  
Функция `PushHeap` должна принимать два аргумента: `begin` - указатель на начало последовательности, `end` - указатель на конец последовательности (элемент следующий за последним). Поведение, ожидающееся от функции: вставляет в пирамиду элемент, находящийся на позиции `end - 1`, восстанавливает пирамиду на диапазоне `[begin, end)`. Гарантируется, что перед выполнением функции `PushHeap` диапазон `[begin, end - 1)` является корректной пирамидой.  
Функция `PopHeap` должна принимать два аргумента: `begin` - указатель на начало последовательности, `end` - указатель на конец последовательности (элемент следующий за последним). Поведение, ожидающееся от функции: меняет местами элемент на позиции `begin` с элементом на позиции `end - 1` и восстанавливает пирамиду на диапазоне `[begin, end - 1)`. Гарантируется, что перед выполнением функции `PopHeap` диапазон `[begin, end)` является корректной пирамидой.  
__Ваш код будет проверяться на скрытых от вас юнит-тестах, проверяющих корректность шаблонной реализации. Требование к реализации: из операций сравнения можно использовать только операцию "<".  
Пришлите на проверку заголовочный файл, содержащий ТОЛЬКО определение шаблона. Он будет включен в cpp файл с тестами автоматически (main писать не нужно!).__
## [T. Нужно больше слияний!](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/T.cpp)
Дано K отсортированных массивов с суммарной длиной N. Слейте их в один большой отсортированный массив размера N. Решение должно работать асимптотически быстрее чем &#937; (NlogN) в худшем случае.
### Формат ввода:
В первой строке идет число K (1 ≤ K ≤ 10<sup>6</sup>). Далее идет K блоков — описания массивов для слияния в следующем формате.  
На первой строке идет число N<sub>i</sub> — размер i-го массива. На второй строке через пробел идут N<sub>i</sub> целых чисел, не превосходящих по модулю 10<sup>9</sup>.  
### Формат вывода:
Выведите N целых чисел в порядке неубывания — массив, полученный в результате слияния K отсортированных массивов.
## [U. Бинаризуй меня](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/U.cpp)
Дана строка. Требуется заменить все числа в ней на двоичные аналоги (перевести из десятичной в двоичную систему счисления).
### Формат ввода:
На вход подается строка из не более 255 символов, среди которых могут быть и пробельные. Гарантируется, что числа в строке не начинаются с 0.
### Формат вывода:
Выведите результат
## [V. Эчпочмак](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/V.cpp)
Из трех отрезков можно составить треугольник, если длина каждого из них не превосходит суммы длин двух других (да, вырожденный треугольник в этой задаче считается треугольником).  
Дан набор из N отрезков. Необходимо выбрать подмножество отрезков с наибольшей суммарной длиной, в котором любые три отрезка могут образовать треугольник.
### Формат ввода:
Вводится число N (1 ≤ N ≤ 30000). В следующих N строках записаны целые числа L<sub>i</sub> (0 ≤ L<sub>i</sub> ≤ 60000), задающие длины отрезков.
### Формат вывода:
Выведите размер найденного множества и суммарную длину отрезков в нем
## [W. Абитуриенты](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/W.cpp)
В ВУЗ поступает N человек. Приемная комиссия хочет набрать M групп по K человек. Главным критерием набора студентов в группы является комфортность обучения в каждой из них. Считается, что чем выше размах (разность между наибольшим и наименьшим значениями) баллов ЕГЭ внутри группы, тем она менее комфортна для обучения.  
Необходимо составить группы так, чтобы максимальное значение размаха в баллах среди них было минимально (чтобы наиболее некомфортная группа была как можно более комфортной).
### Формат ввода:
Вводятся числа N, M и K (1 ≤ M ⋅ K ≤ N ≤ 10<sup>5</sup>). Далее идут N целых чисел --- балл ЕГЭ каждого из абитуриентов. С учетом индивидуальных достижений балл абитуриента не превосходит 10<sup>9</sup>.
### Формат вывода:
Выведите одно число --- наименьшее возможное значение максимального размаха.
## [Y. Простая задачка](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/Y.cpp)
### Формат ввода:
На взод подаются 6 строк длины 20. Входные данные содержат 6 строк по 20 символов. Каждый прямоугольник 6x5 задает цифру циферблата.
### Формат вывода:
Выведите время в формате hh:mm. Если время нельзя определить однозначно, выведите AMBIGUITY. Если же в часах точно сломалось еще что-то, например, неправильный формат времени, либо отображаются лишние пиксели, выведите ERROR.
## [Z. Пиксель-арт](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/Z.cpp)
Дана таблица размера N × M, каждая клетка которой раскрашена в один из K цветов. Цвета пронумерованы числами от 0 до K − 1. Клетка, стоящая в i-й строке и j-м столбце имеет цвет (i + j) % K. Строки и столбцы нумеруются с 0.  
Для каждого цвета укажите, сколько раз он встречается в таблице.
### Формат ввода:
Вводятся числа N, M, K (1 ≤ N, M ≤ 10<sup>9</sup>, 1 ≤ K ≤ 2 ⋅ 10<sup>5</sup>) — размеры таблицы и количество цветов соответственно.
### Формат вывода:
Выведите через пробел K целых чисел, где i-е число обозначает количество клеток, покрашенных в i-й цвет (i от 0 до K − 1).
# [Second_contest](https://github.com/PlatonYadrov/First_semester/tree/main/second_contest)
## [A. Приемная кампания](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/A.cpp)
Ваша цель — реализовать стабильную сортировку для следующей задачи.  
Выведите фамилии и имена абитуриентов, подавших документы на поступление на ПМИ ФПМИ в порядке убывания их среднего балла по ЕГЭ.  
Про каждого ученика известны их фамилии, имена и баллы ЕГЭ по следующим предметам: информатика, математика и русский язык.
### Формат ввода:
В первой строке идет число N (1 ≤ N ≤ 10<sup>5</sup>) — количество абитуриентов, подавших документы.  
Далее идет N строк — описания ученика в формате «surname name inf_points math_points rus_points», где «surname» и «name» — строки длины не более 40, а «*_points» — баллы за экзамены (целые числа от нуля до ста включительно).
### Формат вывода:
Необходимо вывести пары фамилия-имя по одной на строке, разделяя фамилию и имя одним пробелом. Выводить баллы не нужно. Если несколько учащихся имеют одинаковые средние баллы, то их нужно выводить в порядке, заданном во входных данных.
## [B. Гипершашки](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/B.cpp)
Андрей работает судьей на чемпионате по гипершашкам. В каждой игре в гипершашки участвует три игрока. По ходу игры каждый из игроков набирает некоторое положительное целое число баллов. Если после окончания игры первый игрок набрал a баллов, второй — b, а третий c, то говорят, что игра закончилась со счетом a : b : c. Андрей знает, что правила игры гипершашек устроены таким образом, что в результате игры баллы любых двух игроков различаются не более чем в k раз. После матча Андрей показывает его результат, размещая три карточки с очками игроков на специальном табло. Для этого у него есть набор из n карточек, на которых написаны числа x<sub>1</sub>, x<sub>2</sub>, …, x<sub>n</sub>. Чтобы выяснить, насколько он готов к чемпионату, Андрей хочет понять, сколько различных вариантов счета он сможет показать на табло, используя имеющиеся карточки. Требуется написать программу, которая по числу k и значениям чисел на карточках, которые имеются у Андрея, определяет количество различных вариантов счета, которые Андрей может показать на табло.
### Формат ввода:
Первая строка входного файла содержит два целых числа: n и k (3 ≤ n ≤ 100000, 1 ≤ k ≤ 10<sup>9</sup>). Вторая строка входного файла содержит n целых чисел x<sub>1</sub>, x<sub>2</sub>, …, x<sub>n</sub> (1 ≤ x<sub>i</sub> ≤ 10<sup>9</sup>).
### Формат вывода:
Выходной файл должен содержать одно целое число — искомое количество различных вариантов счета.
## [C. Башня из коробок](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/C.cpp)
Недавно у Сережи был день рождения, и его друзья, зная, как ему нравится строить башни, подарили ему N коробок. Сережа живет в 2D мире, поэтому коробки представляют из себя прямоугольники со сторонами, параллельными осям координат. Сережа также умеет поворачивать коробки на 90 градусов.  
Как уже было сказано, Сережа очень любит башни, но не все башни нравятся ему одинаково. Больше всего ему нравятся высокие башни, поэтому он хочет построить как можно более высокую башню из тех коробок, которые ему подарили. Башню можно строить, ставя коробки друг на друга. Для устойчивости башни нужно, чтобы ширина любой коробки была не больше, чем ширина той, на которой она стоит.  
Напишите программу, которая вычислит, какой максимальной высоты устойчивую башню он может построить.
### Формат ввода:
В первой строке вводится целое число N — количество коробок. Далее в N строках идут описания коробок. В (i + 1)-й строке вводятся 2 целых числа: h<sub>i</sub> и w<sub>i</sub> — высота и ширина i-й коробки соответственно (1 ≤ N ≤ 2 ⋅ 10<sup>5</sup>, 1 ≤ w<sub>i</sub>, h<sub>i</sub> ≤ 10<sup>9</sup>).
### Формат вывода:
Выведите одно число — максимальную высоту устойчивой башни из коробок.
## [D. Пирамидальная сортировка. Шаблоны](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/D.cpp)
Реализуйте две шаблонные функции:
* `MakeHeap(begin, end)`, которая принимает указатель на начало и конец последовательности (напомним, конец последовательности - элемент следующий за последним) и переупорядочивает элементы так, чтобы последовательность образовала max-пирамиду.  
* `SortHeap(begin, end)`, которая принимает указатель на начало и конец max-пирамиды и сортирует элементы с помощью пирамидальной сортировки.
__В качестве решения пришлите заголовочный файл с определением шаблонов. main писать не нужно - обработка ввода и вывода будет производиться автоматически!__
### Формат ввода:
В первой строке вводится число N — размер массива (1 ≤ N ≤ 10<sup>5</sup>), во второй идут N целых чисел, не превосходящих по модулю 10<sup>9</sup>.
### Формат вывода:
Выведите отсортированный массив, его элементы необходимо разделять пробелами.
## [E. Приоритетная очередь с удалением](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/E.cpp)
Требуется реализовать приоритетную очередь с помощью бинарной пирамиды, поддерживающую три операции: добавить элемент, извлечь максимальный элемент и удалить заданный элемент. При просеивании нельзя совершать лишние перемещения (например, в случае равенства элементов). Если при просеивании вниз, рассматриваемый элемент можно перемещать как влево вниз, так и вправо вниз, то следует выбрать направление влево.
### Формат ввода:
В первой строке вводятся два числа — максимальный размер приоритетной очереди N и количество запросов M, (1 ≤ M, N ≤ 10<sup>5</sup>). Далее идут M строк, в каждой строке — по одному запросу. Первое число в запросе задает его тип, остальные числа (если есть) — параметры запроса. Тип 1 — извлечь максимальный (без параметров). Тип 2 — добавить данный элемент в очередь. Запрос имеет один параметр — число из диапазона [-10<sup>9</sup>;10<sup>9</sup>]. Тип 3 — удалить элемент по индексу (индексы нумеруются с единицы).
### Формат вывода:
В ответ на запрос типа 1 следует вывести: Если извлекать было нечего (очередь пуста), то -1. Иначе — два числа, первое — индекс конечного положения элемента после его просеивания (если удален последний элемент и просеивать нечего то вывести 0), второе — значение извлеченного элемента.  
В ответ на запрос типа 2 следует вывести: Если добавить нельзя (нет места, т.к. в очередь уже N элементов), то -1. Иначе — индекс добавленного элемента.  
В ответ на запрос типа 3 следует вывести: Если элемента с таким индексом нет и удаление невозможно, то -1. Иначе — значение удаленного элемента.  
После выполнения всех запросов требуется вывести пирамиду в её конечном состоянии
## [F. Дек](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/F.cpp)
Реализуйте тип данных «дек», который поддерживает следующие операции:  
•	push_front — Добавить (положить) в начало дека новый элемент. Программа должна вывести ok.  
•	push_back — Добавить (положить) в конец дека новый элемент. Программа должна вывести ok.  
•	pop_front — Извлечь из дека первый элемент. Программа должна вывести его значение.  
•	pop_back — Извлечь из дека последний элемент. Программа должна вывести его значение.  
•	front — Узнать значение первого элемента (не удаляя его). Программа должна вывести его значение.  
•	back — Узнать значение последнего элемента (не удаляя его). Программа должна вывести его значение.  
•	size — Вывести количество элементов в деке.  
•	clear — Очистить дек (удалить из него все элементы) и вывести ok.  
•	exit — Программа должна закончить свою работу и вывести bye.  
Если во входных данных встречается операция pop_front, pop_back, front, back, и при этом дек пуст, то программа должна вместо числового значения вывести строку error.
### Формат ввода:
В первой строке вводится целое число K (1 ≤ K ≤ 10<sup>5</sup>) количество команд управления деком.  
Далее в каждой новой строке вводятся команды управления деком, по одной на строке.
### Формат вывода:
Требуется вывести протокол работы дека, по одному сообщению на строке.
## [G. Карточная игра](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/G.cpp)
В игре в зожника карточная колода раздается поровну двум игрокам. Далее они вскрывают по одной верхней карте, и тот, чья карта старше, забирает себе обе вскрытые карты, которые кладутся под низ его колоды. Тот, кто остается без карт — проигрывает.  
Для простоты будем считать, что все карты различны по номиналу, а также, что самая младшая карта побеждает самую старшую карту («шестерка берет туза»).  
Игрок, который забирает себе карты, сначала кладет под низ своей колоды карту первого игрока, затем карту второго игрока (то есть карта второго игрока оказывается внизу колоды).  
Напишите программу, которая моделирует игру в зожника и определяет, кто выигрывает. В игре участвует 5 карт, имеющих значения от 0 до 9, большая карта побеждает меньшую, карта со значением 0 побеждает карту 9.  
### Формат ввода:
Программа получает на вход две строки: первая строка содержит 5 чисел, разделенных пробелами — номера карт первого игрока, вторая — аналогично 5 карт второго игрока. Карты перечислены сверху вниз, то есть каждая строка начинается с той карты, которая будет открыта первой.
### Формат вывода:
Программа должна определить, кто выигрывает при данной раздаче, и вывести слово «ﬁrst» или «second», после чего вывести количество ходов, сделанных до выигрыша. Если на протяжении 10<sup>6</sup> ходов игра не заканчивается, программа должна вывести слово «botva».
## [H. Трехвидовая ПСП](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/H.cpp)
Скобочная последовательность состоит из следующих видов скобок: (, ), [, ], {, }. Проверьте является ли введенная скобочная последовательность правильной.
### Формат ввода:
Дана скобочная последовательность из символов выше длиной не более 10<sup>5</sup>.
### Формат вывода:
Выведите YES, если скобочная последовательность правильная, и NO — иначе.
## [I. Польская запись](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/I.cpp)
В постфиксной записи (или обратной польской записи) операция записывается после двух операндов. Например, сумма двух чисел A и B записывается как «A B +». Запись «B C + D *» обозначает привычное нам «(B + C) * D», а запись «A B C + D * +» означает «A + (B + C) * D».
Достоинство постфиксной записи в том, что она не требует скобок и дополнительных соглашений о приоритете операторов для своего чтения.
### Формат ввода:
В единственной строке записано выражение в постфиксной записи, содержащее однозначные числа и операции «+, -, *».
### Формат вывода:
Необходимо вывести значение записанного выражения.
## [J. MinQueue](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/J.cpp)
Реализуйте тип данных «очередь c поддержкой минимума», который поддерживает следующие операции:  
•	«enqueue n» Добавить в хвост очереди число n (1 ≤ n ≤ 10<sup>9</sup>) (значение n задается после команды). Программа должна вывести «ok».  
•	«dequeue» Удалить из очереди головной элемент. Программа должна вывести его значение.  
•	«front» Программа должна вывести значение головного элемента, не удаляя его из очереди.  
•	«size» Программа должна вывести количество элементов в очереди.  
•	«clear» Программа должна очистить очередь и вывести «ok».  
•	«min» Программа должна вывести минимум в очереди, не удаляя его из очереди.  
Если во входных данных встречается операция «front», «dequeue» или «min», и при этом очередь пуста, то программа должна вместо числового значения вывести строку «error».
### Формат ввода:
В первой строке входных данных записано единственное число M (1 ≤ M ≤ 2 ⋅ 10<sup>5</sup>) — количество команд. В следующих М строках дано по одной команде из тех, что идут выше.
### Формат вывода:
Для каждой команды выведите одну строчку — результат ее выполнения.
## [K. Минимум на отрезке](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/K.cpp)
Рассмотрим последовательность целых чисел длины N. По ней с шагом 11 двигается "окно" длины K, то есть сначала в "окне" видно первые K чисел, на следующем шаге в "окне" уже будут находиться K чисел, начиная со второго, и так далее до конца последовательности. Требуется для каждого положения "окна" определить минимум в нём.
### Формат ввода:

### Формат вывода:
