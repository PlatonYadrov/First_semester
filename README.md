# [First_contest](https://github.com/PlatonYadrov/First_semester/tree/main/first_contest)
## [A. Жизнь в квадрате](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/A.cpp "Задача A")
В некоторых клетках квадрата N×N живут микроорганизмы (не более одного в одной клетке). Каждую секунду происходит следующее: -- все микроорганизмы, у которых менее 2-х соседей, умирают от скуки (соседями называются микроорганизмы, живущие в клетках, имеющих общую сторону или вершину); -- все микроорганизмы, у которых более 3-х соседей, умирают от перенаселенности; -- на всех пустых клетках, у которых ровно в трех соседних клетках жили микроорганизмы, появляются новые микроорганизмы. Все изменения происходят одновременно, то есть для каждой клетки сначала выясняется ее судьба, а затем происходят изменения сразу во всех клетках. Требуется по данной конфигурации определить, во что она превратится через T секунд.
### Формат ввода
В первой строке вводятся два натуральных числа -- N (1 ≤ N ≤ 10) и T (1 ≤ T ≤ 100). Далее записано N строчек по N чисел, описывающих начальную конфигурацию (0 -- пустая клетка, 1 -- микроорганизм). Числа в строках разделены пробелами.
### Формат вывода
Требуется вывести N строк по N чисел -- описание конфигурации через T секунд (в том же формате, как и во входных данных).
## [B. Тетрадка](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/B.cpp)
Проектная работа Виталика по компьютерному зрению заключается в распознавании типа тетрадки по небольшому ее участку (в клетку, в линейку, в вертикальную линейку). Однако времени обучать нейросеть у Виталика нет, поэтому он попросил вас помочь ему написать программу на C++, которая бы делала это без привлечения искусственного интеллекта (почему вы согласились на это, и почему эта задача обязательна, легенда умалчивает).  
Часть тетрадки представляет собой двумерную таблицу из нулей и единиц, где единица — закрашенный участок, а нуль — незакрашенный. Вертикальной линией считается столбец, в котором стоят только единицы, горизонтальной — строка, второй стоят только единицы. Гарантируется, что тетрадь изначально пустая, то есть единица обязательно является частью какой-то линии.  
Тетрадь в горизонтальную линейку состоит только из горизонтальных линий, в вертикальную линейку — только из вертикальных линий, в клетку — из линий обоих типов. Причем расстояния между всеми параллельными линиями одинаковы (клетки - обязательно квадраты), и между ними обязательно есть пустоты (не могут располагаться вплотную).  
По заданному участку выведите тип тетради, если его возможно однозначно определить.
### Формат ввода
В первой строке даны целые числа n и m (1 ≤ n, m ≤ 1 000) — количество строк и столбцов в видимом участке. Далле следует n строк по m целых чисел a<sub>i,j</sub> (0 ≤ a<sub>i,j</sub> ≤ 1) — видимый участок тетради.
### Формат вывода
В качестве ответа выведите:  
«Square», если тетрадка в клетку; «Line», если тетрадка в линейку; «Vertical line», если тетрадка в вертикальную линейку; «?», если невозможно однозначно определить, к какому типу относится данная тетрадь.
## [C. Мирные ферзи](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/C.cpp)
Дано число N. Определите, сколькими способами можно расставить на доске N × N N ферзей, не бьющих друг друга.
### Формат ввода
Задано единственное число N, N ≤ 10.
### Формат вывода
Необходимо вывести количество способов, которыми можно расставить на доске N × N N ферзей, не бьющих друг друга.
## [D. Фишки](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/D.cpp)
Дана полоска из клеток, пронумерованных от 1 до N. На каждом ходе разрешено поставить фишку на клетку (если её там еще нет) или снять фишку с клетки (если она там есть). При любом действии (постановка фишки или снятие фишки), можно выбрать не любую клетку, а только клетку под номером 1 или клетку, следующую за самой первой фишкой. Изначально полоска пуста. Требуется занять все клетки. Как только все клетки заполнены - действия прекращаются.
### Формат ввода
С клавиатуры вводится натуральное число N (1 ≤ N ≤ 10).
### Формат вывода
Требуется вывести последовательность номеров клеток, с которыми совершается действие в строку через пробел. Если фишка снимается, то номер клетки должен выводиться со знаком минус. Количество действий не должно превышать 10<sup>4</sup>. Если существует несколько возможных решений задачи, то разрешается вывести любое.
## [E. Монетки](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/E.cpp)
В Волшебной стране используются монетки достоинством A<sub>1</sub>, A<sub>2</sub>,..., A<sub>M</sub>. Волшебный человечек пришел в магазин и обнаружил, что у него есть ровно по две монетки каждого достоинства. Ему нужно заплатить сумму N. Напишите программу, определяющую, сможет ли он расплатиться без сдачи.
### Формат ввода
На вход программы сначала поступает число N (1 ≤ N ≤ 10<sup>9</sup>), затем - число M (1 ≤ M ≤ 15) и далее M попарно различных чисел A<sub>1</sub>, A<sub>2</sub>,..., A<sub>M</sub> (1 ≤ A<sub>i</sub> ≤ 10<sup>9</sup>).
### Формат вывода
Сначала выведите K - количество монет, которое придется отдать Волшебному человечку, если он сможет заплатить указанную сумму без сдачи. Далее выведите K чисел, задающих достоинства монет. Если решений несколько, выведите вариант, в котором Волшебный человек отдаст наименьшее возможное количество монет. Если таких вариантов несколько, выведите любой из них.  
Если без сдачи не обойтись, то выведите одно число 0. Если же у Волшебного человечка не хватит денег, чтобы заплатить указанную сумму, выведите одно число -1 (минус один).
## [F. Ханойские башни](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/F.cpp)
Головоломка "Ханойские башни" состоит из трех стержней, пронумерованных числами 1, 2, 3. На стержень 1 надета пирамидка из n дисков различного диаметра в порядке возрастания диаметра. Диски можно перекладывать с одного стержня на другой по одному, при этом диск нельзя класть на диск меньшего диаметра. Необходимо переложить всю пирамидку со стержня 1 на стержень 3 за минимальное число перекладываний.  
Напишите программу, которая решает головоломку; для данного числа дисков n печатает последовательность перекладываний в формате a, b, c, где a — номер перекладываемого диска, b — номер стержня с которого снимается данный диск, c — номер стержня на который надевается данный диск.  
Например, строка 1 2 3 означает перемещение диска номер 1 со стержня 2 на стержень 3. В одной строке печатается одна команда. Диски пронумерованы числами от 1 до n в порядке возрастания диаметров.
### Формат ввода
Вводится натуральное число n (1 ≤ n ≤ 10).
### Формат вывода
Программа должна вывести минимальный (по количеству произведенных операций) способ перекладывания пирамидки из данного числа дисков.
## [G. Несправедливые башни](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/G.cpp)
В Ханое несправедливо запретили класть самый маленький диск (номер 1) на средний колышек (номер 2).  
Решите головоломку с учетом этих ограничений. Вам не нужно находить минимальное решение, но количество совершенных перемещений не должно быть больше 200000, при условии, что количество дисков не превосходит 10.
### Формат ввода
Вводится натуральное число n.
### Формат вывода
Выведите ответ на задачу.
## [H. Данные под защитой](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/H.cpp)
В одной неизвестной соцсети используется следующий алгоритм шифрования сообщений. Каждой букве слова присвается некоторый номер: первой букве - номер 1, последней - номер 2, второй - номер 3, предпоследней - номер 4, и так далее. Далее буквы записываются в порядке следования номеров и в конец приписывается символ '#'.  
Пример: слово «надежность» будет передано как «ньатдсеожн#».  
Вам удалось перехватить одно из сообщений. Напишите программу, которая дешифрует полученное слово.
### Формат ввода
На вход подается шифр из не более 10<sup>5</sup> букв
### Формат вывода
Напечатайте исходное слово
## [I. Работник месяца](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/I.cpp)
Директор предприятия решил поощрять наиболее отличившихся сотрудников и каждый месяц вешать N лучших из них на доску почета. Фотографии каждого из сотрудников представляют собой прямоугольник W × H, а доска по плану директора имеет форму квадрата. Напишите программу, которая по данным W, H и N вычисляет минимальную длину стороны доски, достаточную для размещения всех фотографий. Фотографии на доске не могут быть повернуты, а также пересекаться между собой.
### Формат ввода
На вход подается три целых числа: W, H, N (1 ≤ W, H, N ≤ 10<sup>9</sup>).
### Формат вывода
В выходной файл необходимо вывести ответ на поставленную задачу.
## [J. Палиндром](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/J.cpp)
Палиндромом называется строка, которая, после удаления из нее всех пробелов и знаков препинания, читается одинаково справа налево и слева направо.
По заданной строке нужно определить, можно ли с помощью одного изменения (замены символа, удаления или добавления) превратить ее в палиндром. В палиндроме учитываются только латинские буквы без учета регистра. То есть строки "aba, cA !Ba" и "abacaba" задают один и тот же палиндром.
### Формат ввода
Дана строка s (1 ≤ |s| ≤ 10<sup>5</sup>)
### Формат вывода
Выведите YES, если палиндром получить можно, и NO иначе. В случае ответа YES выведите полученный палиндром.
## [K. Лень - двигатель прогресса](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/K.cpp)
Виталик заметил, что сдача задач по алгоритмам в свою очередь сводится к другому алгоритму, состоящему из небольшого количества уникальных действий (открытие файла, сборка, тестирование, и т.д.). Всего он выявил 26 таких действий и обозначил каждое из них строчной буквой латинского алфавита (вот совпадение!).  
Для оптимизации времени, потраченного на сдачу заданий, Виталик решил написать программу (скрипт), который бы автоматизировал некоторую часть этой рутинной работы. Идея довольно проста: скрипт в цикле выполняет K фиксированных действий подряд, то есть сначала выполняется первое действие, затем второе и т.д. после окончания последнего действия работа скрипта продолжается с первого. При этом скрипт останавливается после фиксированного числа шагов (которое указывает Виталик). Время затраченное на написание скрипта Виталик считает оправданным, если он выполнит хотя бы K + 1 действие. Скрипт может запускаться только один раз.  
По заданной последовательности действий определите количество способов написать "оправданный"скрипт.
### Формат ввода
В первой строке записано число K > 0 — количество действий, которые выполняются в цикле скрипта. Во второй строке записаны N (K < N ≤ 10<sup>6</sup>) строчных латинских букв, обозначающих алгоритм сдачи задания.
### Формат вывода
Выведите ответ на задачу
## [L. Одинаковые элементы](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/L.cpp)
Напишите программу, проверяющую совпадают ли множества уникальных элементов двух массивов.
### Формат ввода
Вводится число N (1 ≤ N ≤ 100000) – размер первого массива. Во второй строке идет N целых чисел, не превосходящих по модулю 10<sup>9</sup> – элементы массива. Далее аналогично задается второй массив.
### Формат вывода
Программа должна вывести слово YES, если множества уникальных элементов совпадают, и слово NO в противном случае.
## [M. Количество инверсий](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/M.cpp)
Напишите программу, которая для заданного массива A=a<sub>1</sub>, a<sub>2</sub>,..., a<sub>n</sub> находит количество пар (i, j) таких , что i < j и a<sub>i</sub> > a<sub>j</sub>.
### Формат ввода
Первая строка входного файла содержит натуральное число n (1 ≤ n ≤ 500000) --- количество элементов массива. Вторая строка содержит n элементов массива A (
0 ≤ a<sub>i</sub> ≤ 10<sup>6</sup>).
### Формат вывода
В выходной файл выведите одно число --- ответ на задачу.
## [N. CString](https://github.com/PlatonYadrov/First_semester/tree/main/first_contest/ctring)
<i>C-style строкой называется последовательность байт (char), ограниченная нулевым символом ('\0'). Работа с C-style строками во многом похожа на работу с массивами, при этом специфичные для строк операции (вычисление длины, конкатенация, сравнение и т.п.) вынесены в отдельную библиотеку функций <cstring>. В этом задании вам предстоит познакомиться с ней подробнее, реализовав собственный аналог.</i>
### Условие задачи
Реализуйте модуль `cstring`, состоящий из следующих функций:
* `size_t Strlen(const char* str)`;. Вычисляет длину строки `str` (без учета нулевого символа).
* `int Strcmp(const char* first, const char* second)`;. Лексикографически сравнивает две строки. Если `first < second`, то возвращает произвольное отрицательное число, если `first > second`, то - положительное. В случае равенства возвращает 0.
* `int Strncmp(const char* first, const char* second, size_t count)`;. То же, что и предыдущая функция, но сравнивает первые count символов строк (либо пока не встретит нулевой символ).
* `char* Strcpy(char* dest, const char* src)`;. Принимает строку src и копирует ее содержимое (вместе с нуль-терминатором) в `dest`. Гарантируется, что `dest` указывает на область памяти, достаточную для хранения `src`. Возвращает `dest`.
* `char* Strncpy(char* dest, const char* src, size_t count)`;. То же, что и предыдущая функция, но копирует ровно count символов из `src`. Если `count` больше размера `src`, то оставшиеся символы заполняются нуль-символами. Возвращает `dest`.
* `char* Strcat(char* dest, const char* src)`;. Приписывает строку src в конец строки `dest` (конкатенация строк). Гарантируется, что `dest` указывает на область памяти, достаточную для хранения итоговой строки. Возвращает `dest`.
* `char* Strncat(char* dest, const char* src, size_t count)`;. То же, что и предыдущая функция, но добавляет только первые `count` символов из `src` + нулевой символ. Если count больше чем длина `src`, то работает так же как и `Strcat(dest, src)`. Возвращает `dest`.
* `const char* Strchr(const char* str, char symbol)`;. Возвращает указатель на первое появление символа `symbol` в строке `str` (с учетом нулевого символа), либо нулевой указатель, если такого символа нет.
* `const char* Strrchr(const char* str, char symbol)`;. Возвращает указатель на последнее появление символа `symbol` в строке `str` (с учетом нулевого символа), либо нулевой указатель, если такого символа нет.
* `size_t Strspn(const char* dest, const char* src)`;. Возвращает количество первых символов `dest`, которые встречаются в строке `src` (без учета нулевого символа).
* `size_t Strcspn(const char* dest, const char* src)`;. Возвращает количество первых символов `dest`, которые не встречаются в строке `src` (без учета нулевого символа).
* `const char* Strpbrk(const char* dest, const char* breakset)`;. Возвращает указатель на первый элемент `dest`, который лежит в `breakset`, либо нулевой указатель, если такого элемента нет.
* `const char* Strstr(const char* str, const char* pattern)`;. Осуществляет поиск подстроки `pattern` в строке `str`. Возвращает указатель на начало первого вхождения, либо нулевой указатель, если вхождения найдено не было.  
При необходимости подробнее про работу функций можете прочитать на странице [https://cplusplus.com/reference/cstring/](https://cplusplus.com/reference/cstring/) . Использовать функции `memcpy`, `memcmp` и подобные запрещено.  
В качестве решения от вас ожидается модуль, состоящий из 2х файлов: `cstring.h` и `cstring.cpp`. Файлы присылайте в виде ZIP-архива.  
Присланный модуль будет собран вместе с файлом с тестами на сервере, `main` присылать не нужно. Интерфейс функций должен в точности совпадать с тем, что описан в условии (тесты ожидают именно его), в противном случае вы получите ошибку компиляции.  
При ошибке в реализации вы получите вердикт RE. В нем будет указана функция, которая требует исправлений.
## [O. Бинпоиск. Шаблоны](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/O.cpp)
Пришлите заголовочный файл с определениями трех шаблонных функций для работы с отсортированными последовательностями. Каждая функция принимает три аргумента: _begin_ - указатель на начало последовательности, _end_ - указатель на конец последовательности (элемент следующий за последним), _value_ - запрос.  
* __BinarySearch:__
функция, осуществляющая проверку наличия элемента _value_ в отсортированной последовательности _[begin,end)_. Возвращает _true_, если и только если на полуинтервале _[begin,end)_ имеется значение _value_.
* __LowerBound:__
функция, осуществляющая поиск первого элемента не меньшего (≥) _value_ на полуинтервале _[begin,end)_. Возвращает указатель на найденный элемент, либо _end_, если такого нет.
* __UpperBound:__
функция, осуществляющая поиск первого элемента строго большего (>) _value_ на полуинтервале _[begin,end)_. Возвращает указатель на найденный элемент, либо _end_, если такого нет.  
__Важно__: используйте только сравнение на меньше (<) и избегайте лишних копирований элементов. То есть считайте, что элементы последовательности не копируемы и могут быть сравнены только с помощью операции <.
### Формат ввода:
__Данная информация нужна только для понимания примера. Обработку пользовательского ввода писать не нужно. Вместо указателей в примере вводятся и выводятся индексы элементов.__  
На первой строчке подается число элементов в последовательности, а далее сами элементы.  
В следующих строках следует число запросов и сами запросы в формате (_begin, end, value_).  
### Формат вывода:
__Данная информация нужна только для понимания примера. Ваши функции ничего выводить не должны.__  
Выводятся 3 числа - результаты вызова _BinarySearch, LowerBound и UpperBound_ соответственно.
## [P. Слияние. Шаблоны](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/P.cpp)
Реализуйте шаблонную функцию `Merge`, которая принимает две отсортированные последовательности и сливает их одну большую отсортированную.  
Функция должна принимать 5 аргументов: `first_begin, first_end` - указатели на начало и конец первой последовательности; `second_begin, second_end` - начало и конец второй последовательности; `out` - указатель на начало итоговой последовательности (куда записывать ответ).  
Последовательности `first, second` и out могут хранить значения разных типов!  
__Ваш код будет проверяться на скрытых от вас юнит-тестах, проверяющих корректность шаблонной реализации. Требование к реализации: из операций сравнения можно использовать только операцию "<".  
Пришлите на проверку заголовочный файл, содержащий ТОЛЬКО определение шаблона. Он будет включен в cpp файл с тестами автоматически (main писать не нужно!).__
## [Q. Сортировка. Шаблоны](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/Q.cpp)
В данной задаче вам необходимо реализовать шаблонную функцию `Sort`, сортирующую переданную последовательность. Функция должна принимать два аргумента: `begin` - указатель на начало последовательности, `end` - указатель на конец последовательности (элемент следующий за последним).  
__Ваш код будет проверяться на скрытых от вас юнит-тестах, проверяющих корректность шаблонной реализации. Требование к реализации: из операций сравнения можно использовать только операцию "<".  
Пришлите на проверку заголовочный файл, содержащий ТОЛЬКО определение шаблона. Он будет включен в cpp файл с тестами автоматически (main писать не нужно!).__
## [R. k-я порядковая статистика. Шаблоны](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/R.cpp)
Реализуйте шаблонную функцию _KthElement_, которая упорядочивает элементы последовательности так, чтобы на k-м месте (в 0 индексации) стоял k-й по величине элемент последовательности.  
Функция должна принимать 3 аргумента: `begin` - указатель на начало последовательности; `kth` - указатель на k-ю позицию; `end` - указатель на конец последовательности.  
Среднее время работы алгоритма должно быть линейным от длины полуинтервала `[begin, end)`.  
__Ваш код будет проверяться на скрытых от вас юнит-тестах, проверяющих корректность шаблонной реализации. Требование к реализации: из операций сравнения можно использовать только операцию "<".  
Пришлите на проверку заголовочный файл, содержащий ТОЛЬКО определение шаблона. Он будет включен в cpp файл с тестами автоматически (main писать не нужно!).__
## [S. Приоритетная очередь. Шаблоны](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/S.cpp)
В данной задаче вам необходимо реализовать шаблонные функции для работы с бинарной пирамидой (с максимумом на вершине):  
__PushHeap__ - восстанавливает пирамиду после добавления нового элемента (`Insert`);  
__PopHeap__ - восстанавливает пирамиду после извлечения максимального элемента из пирамиды.  
Функция `PushHeap` должна принимать два аргумента: `begin` - указатель на начало последовательности, `end` - указатель на конец последовательности (элемент следующий за последним). Поведение, ожидающееся от функции: вставляет в пирамиду элемент, находящийся на позиции `end - 1`, восстанавливает пирамиду на диапазоне `[begin, end)`. Гарантируется, что перед выполнением функции `PushHeap` диапазон `[begin, end - 1)` является корректной пирамидой.  
Функция `PopHeap` должна принимать два аргумента: `begin` - указатель на начало последовательности, `end` - указатель на конец последовательности (элемент следующий за последним). Поведение, ожидающееся от функции: меняет местами элемент на позиции `begin` с элементом на позиции `end - 1` и восстанавливает пирамиду на диапазоне `[begin, end - 1)`. Гарантируется, что перед выполнением функции `PopHeap` диапазон `[begin, end)` является корректной пирамидой.  
__Ваш код будет проверяться на скрытых от вас юнит-тестах, проверяющих корректность шаблонной реализации. Требование к реализации: из операций сравнения можно использовать только операцию "<".  
Пришлите на проверку заголовочный файл, содержащий ТОЛЬКО определение шаблона. Он будет включен в cpp файл с тестами автоматически (main писать не нужно!).__
## [T. Нужно больше слияний!](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/T.cpp)
Дано K отсортированных массивов с суммарной длиной N. Слейте их в один большой отсортированный массив размера N. Решение должно работать асимптотически быстрее чем &#937; (NlogN) в худшем случае.
### Формат ввода:
В первой строке идет число K (1 ≤ K ≤ 10<sup>6</sup>). Далее идет K блоков — описания массивов для слияния в следующем формате.  
На первой строке идет число N<sub>i</sub> — размер i-го массива. На второй строке через пробел идут N<sub>i</sub> целых чисел, не превосходящих по модулю 10<sup>9</sup>.  
### Формат вывода:
Выведите N целых чисел в порядке неубывания — массив, полученный в результате слияния K отсортированных массивов.
## [U. Бинаризуй меня](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/U.cpp)
Дана строка. Требуется заменить все числа в ней на двоичные аналоги (перевести из десятичной в двоичную систему счисления).
### Формат ввода:
На вход подается строка из не более 255 символов, среди которых могут быть и пробельные. Гарантируется, что числа в строке не начинаются с 0.
### Формат вывода:
Выведите результат
## [V. Эчпочмак](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/V.cpp)
Из трех отрезков можно составить треугольник, если длина каждого из них не превосходит суммы длин двух других (да, вырожденный треугольник в этой задаче считается треугольником).  
Дан набор из N отрезков. Необходимо выбрать подмножество отрезков с наибольшей суммарной длиной, в котором любые три отрезка могут образовать треугольник.
### Формат ввода:
Вводится число N (1 ≤ N ≤ 30000). В следующих N строках записаны целые числа L<sub>i</sub> (0 ≤ L<sub>i</sub> ≤ 60000), задающие длины отрезков.
### Формат вывода:
Выведите размер найденного множества и суммарную длину отрезков в нем
## [W. Абитуриенты](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/W.cpp)
В ВУЗ поступает N человек. Приемная комиссия хочет набрать M групп по K человек. Главным критерием набора студентов в группы является комфортность обучения в каждой из них. Считается, что чем выше размах (разность между наибольшим и наименьшим значениями) баллов ЕГЭ внутри группы, тем она менее комфортна для обучения.  
Необходимо составить группы так, чтобы максимальное значение размаха в баллах среди них было минимально (чтобы наиболее некомфортная группа была как можно более комфортной).
### Формат ввода:
Вводятся числа N, M и K (1 ≤ M ⋅ K ≤ N ≤ 10<sup>5</sup>). Далее идут N целых чисел --- балл ЕГЭ каждого из абитуриентов. С учетом индивидуальных достижений балл абитуриента не превосходит 10<sup>9</sup>.
### Формат вывода:
Выведите одно число --- наименьшее возможное значение максимального размаха.
## [Y. Простая задачка](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/Y.cpp)
### Формат ввода:
На взод подаются 6 строк длины 20. Входные данные содержат 6 строк по 20 символов. Каждый прямоугольник 6x5 задает цифру циферблата.
### Формат вывода:
Выведите время в формате hh:mm. Если время нельзя определить однозначно, выведите AMBIGUITY. Если же в часах точно сломалось еще что-то, например, неправильный формат времени, либо отображаются лишние пиксели, выведите ERROR.
## [Z. Пиксель-арт](https://github.com/PlatonYadrov/First_semester/blob/main/first_contest/Z.cpp)
Дана таблица размера N × M, каждая клетка которой раскрашена в один из K цветов. Цвета пронумерованы числами от 0 до K − 1. Клетка, стоящая в i-й строке и j-м столбце имеет цвет (i + j) % K. Строки и столбцы нумеруются с 0.  
Для каждого цвета укажите, сколько раз он встречается в таблице.
### Формат ввода:
Вводятся числа N, M, K (1 ≤ N, M ≤ 10<sup>9</sup>, 1 ≤ K ≤ 2 ⋅ 10<sup>5</sup>) — размеры таблицы и количество цветов соответственно.
### Формат вывода:
Выведите через пробел K целых чисел, где i-е число обозначает количество клеток, покрашенных в i-й цвет (i от 0 до K − 1).
# [Second_contest](https://github.com/PlatonYadrov/First_semester/tree/main/second_contest)
## [A. Приемная кампания](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/A.cpp)
Ваша цель — реализовать стабильную сортировку для следующей задачи.  
Выведите фамилии и имена абитуриентов, подавших документы на поступление на ПМИ ФПМИ в порядке убывания их среднего балла по ЕГЭ.  
Про каждого ученика известны их фамилии, имена и баллы ЕГЭ по следующим предметам: информатика, математика и русский язык.
### Формат ввода:
В первой строке идет число N (1 ≤ N ≤ 10<sup>5</sup>) — количество абитуриентов, подавших документы.  
Далее идет N строк — описания ученика в формате «surname name inf_points math_points rus_points», где «surname» и «name» — строки длины не более 40, а «*_points» — баллы за экзамены (целые числа от нуля до ста включительно).
### Формат вывода:
Необходимо вывести пары фамилия-имя по одной на строке, разделяя фамилию и имя одним пробелом. Выводить баллы не нужно. Если несколько учащихся имеют одинаковые средние баллы, то их нужно выводить в порядке, заданном во входных данных.
## [B. Гипершашки](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/B.cpp)
Андрей работает судьей на чемпионате по гипершашкам. В каждой игре в гипершашки участвует три игрока. По ходу игры каждый из игроков набирает некоторое положительное целое число баллов. Если после окончания игры первый игрок набрал a баллов, второй — b, а третий c, то говорят, что игра закончилась со счетом a : b : c. Андрей знает, что правила игры гипершашек устроены таким образом, что в результате игры баллы любых двух игроков различаются не более чем в k раз. После матча Андрей показывает его результат, размещая три карточки с очками игроков на специальном табло. Для этого у него есть набор из n карточек, на которых написаны числа x<sub>1</sub>, x<sub>2</sub>, …, x<sub>n</sub>. Чтобы выяснить, насколько он готов к чемпионату, Андрей хочет понять, сколько различных вариантов счета он сможет показать на табло, используя имеющиеся карточки. Требуется написать программу, которая по числу k и значениям чисел на карточках, которые имеются у Андрея, определяет количество различных вариантов счета, которые Андрей может показать на табло.
### Формат ввода:
Первая строка входного файла содержит два целых числа: n и k (3 ≤ n ≤ 100000, 1 ≤ k ≤ 10<sup>9</sup>). Вторая строка входного файла содержит n целых чисел x<sub>1</sub>, x<sub>2</sub>, …, x<sub>n</sub> (1 ≤ x<sub>i</sub> ≤ 10<sup>9</sup>).
### Формат вывода:
Выходной файл должен содержать одно целое число — искомое количество различных вариантов счета.
## [C. Башня из коробок](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/C.cpp)
Недавно у Сережи был день рождения, и его друзья, зная, как ему нравится строить башни, подарили ему N коробок. Сережа живет в 2D мире, поэтому коробки представляют из себя прямоугольники со сторонами, параллельными осям координат. Сережа также умеет поворачивать коробки на 90 градусов.  
Как уже было сказано, Сережа очень любит башни, но не все башни нравятся ему одинаково. Больше всего ему нравятся высокие башни, поэтому он хочет построить как можно более высокую башню из тех коробок, которые ему подарили. Башню можно строить, ставя коробки друг на друга. Для устойчивости башни нужно, чтобы ширина любой коробки была не больше, чем ширина той, на которой она стоит.  
Напишите программу, которая вычислит, какой максимальной высоты устойчивую башню он может построить.
### Формат ввода:
В первой строке вводится целое число N — количество коробок. Далее в N строках идут описания коробок. В (i + 1)-й строке вводятся 2 целых числа: h<sub>i</sub> и w<sub>i</sub> — высота и ширина i-й коробки соответственно (1 ≤ N ≤ 2 ⋅ 10<sup>5</sup>, 1 ≤ w<sub>i</sub>, h<sub>i</sub> ≤ 10<sup>9</sup>).
### Формат вывода:
Выведите одно число — максимальную высоту устойчивой башни из коробок.
## [D. Пирамидальная сортировка. Шаблоны](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/D.cpp)
Реализуйте две шаблонные функции:
* `MakeHeap(begin, end)`, которая принимает указатель на начало и конец последовательности (напомним, конец последовательности - элемент следующий за последним) и переупорядочивает элементы так, чтобы последовательность образовала max-пирамиду.  
* `SortHeap(begin, end)`, которая принимает указатель на начало и конец max-пирамиды и сортирует элементы с помощью пирамидальной сортировки.
__В качестве решения пришлите заголовочный файл с определением шаблонов. main писать не нужно - обработка ввода и вывода будет производиться автоматически!__
### Формат ввода:
В первой строке вводится число N — размер массива (1 ≤ N ≤ 10<sup>5</sup>), во второй идут N целых чисел, не превосходящих по модулю 10<sup>9</sup>.
### Формат вывода:
Выведите отсортированный массив, его элементы необходимо разделять пробелами.
## [E. Приоритетная очередь с удалением](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/E.cpp)
Требуется реализовать приоритетную очередь с помощью бинарной пирамиды, поддерживающую три операции: добавить элемент, извлечь максимальный элемент и удалить заданный элемент. При просеивании нельзя совершать лишние перемещения (например, в случае равенства элементов). Если при просеивании вниз, рассматриваемый элемент можно перемещать как влево вниз, так и вправо вниз, то следует выбрать направление влево.
### Формат ввода:
В первой строке вводятся два числа — максимальный размер приоритетной очереди N и количество запросов M, (1 ≤ M, N ≤ 10<sup>5</sup>). Далее идут M строк, в каждой строке — по одному запросу. Первое число в запросе задает его тип, остальные числа (если есть) — параметры запроса. Тип 1 — извлечь максимальный (без параметров). Тип 2 — добавить данный элемент в очередь. Запрос имеет один параметр — число из диапазона [-10<sup>9</sup>;10<sup>9</sup>]. Тип 3 — удалить элемент по индексу (индексы нумеруются с единицы).
### Формат вывода:
В ответ на запрос типа 1 следует вывести: Если извлекать было нечего (очередь пуста), то -1. Иначе — два числа, первое — индекс конечного положения элемента после его просеивания (если удален последний элемент и просеивать нечего то вывести 0), второе — значение извлеченного элемента.  
В ответ на запрос типа 2 следует вывести: Если добавить нельзя (нет места, т.к. в очередь уже N элементов), то -1. Иначе — индекс добавленного элемента.  
В ответ на запрос типа 3 следует вывести: Если элемента с таким индексом нет и удаление невозможно, то -1. Иначе — значение удаленного элемента.  
После выполнения всех запросов требуется вывести пирамиду в её конечном состоянии
## [F. Дек](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/F.cpp)
Реализуйте тип данных «дек», который поддерживает следующие операции:  
•	push_front — Добавить (положить) в начало дека новый элемент. Программа должна вывести ok.  
•	push_back — Добавить (положить) в конец дека новый элемент. Программа должна вывести ok.  
•	pop_front — Извлечь из дека первый элемент. Программа должна вывести его значение.  
•	pop_back — Извлечь из дека последний элемент. Программа должна вывести его значение.  
•	front — Узнать значение первого элемента (не удаляя его). Программа должна вывести его значение.  
•	back — Узнать значение последнего элемента (не удаляя его). Программа должна вывести его значение.  
•	size — Вывести количество элементов в деке.  
•	clear — Очистить дек (удалить из него все элементы) и вывести ok.  
•	exit — Программа должна закончить свою работу и вывести bye.  
Если во входных данных встречается операция pop_front, pop_back, front, back, и при этом дек пуст, то программа должна вместо числового значения вывести строку error.
### Формат ввода:
В первой строке вводится целое число K (1 ≤ K ≤ 10<sup>5</sup>) количество команд управления деком.  
Далее в каждой новой строке вводятся команды управления деком, по одной на строке.
### Формат вывода:
Требуется вывести протокол работы дека, по одному сообщению на строке.
## [G. Карточная игра](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/G.cpp)
В игре в зожника карточная колода раздается поровну двум игрокам. Далее они вскрывают по одной верхней карте, и тот, чья карта старше, забирает себе обе вскрытые карты, которые кладутся под низ его колоды. Тот, кто остается без карт — проигрывает.  
Для простоты будем считать, что все карты различны по номиналу, а также, что самая младшая карта побеждает самую старшую карту («шестерка берет туза»).  
Игрок, который забирает себе карты, сначала кладет под низ своей колоды карту первого игрока, затем карту второго игрока (то есть карта второго игрока оказывается внизу колоды).  
Напишите программу, которая моделирует игру в зожника и определяет, кто выигрывает. В игре участвует 5 карт, имеющих значения от 0 до 9, большая карта побеждает меньшую, карта со значением 0 побеждает карту 9.  
### Формат ввода:
Программа получает на вход две строки: первая строка содержит 5 чисел, разделенных пробелами — номера карт первого игрока, вторая — аналогично 5 карт второго игрока. Карты перечислены сверху вниз, то есть каждая строка начинается с той карты, которая будет открыта первой.
### Формат вывода:
Программа должна определить, кто выигрывает при данной раздаче, и вывести слово «ﬁrst» или «second», после чего вывести количество ходов, сделанных до выигрыша. Если на протяжении 10<sup>6</sup> ходов игра не заканчивается, программа должна вывести слово «botva».
## [H. Трехвидовая ПСП](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/H.cpp)
Скобочная последовательность состоит из следующих видов скобок: (, ), [, ], {, }. Проверьте является ли введенная скобочная последовательность правильной.
### Формат ввода:
Дана скобочная последовательность из символов выше длиной не более 10<sup>5</sup>.
### Формат вывода:
Выведите YES, если скобочная последовательность правильная, и NO — иначе.
## [I. Польская запись](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/I.cpp)
В постфиксной записи (или обратной польской записи) операция записывается после двух операндов. Например, сумма двух чисел A и B записывается как «A B +». Запись «B C + D *» обозначает привычное нам «(B + C) * D», а запись «A B C + D * +» означает «A + (B + C) * D».
Достоинство постфиксной записи в том, что она не требует скобок и дополнительных соглашений о приоритете операторов для своего чтения.
### Формат ввода:
В единственной строке записано выражение в постфиксной записи, содержащее однозначные числа и операции «+, -, *».
### Формат вывода:
Необходимо вывести значение записанного выражения.
## [J. MinQueue](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/J.cpp)
Реализуйте тип данных «очередь c поддержкой минимума», который поддерживает следующие операции:  
•	«enqueue n» Добавить в хвост очереди число n (1 ≤ n ≤ 10<sup>9</sup>) (значение n задается после команды). Программа должна вывести «ok».  
•	«dequeue» Удалить из очереди головной элемент. Программа должна вывести его значение.  
•	«front» Программа должна вывести значение головного элемента, не удаляя его из очереди.  
•	«size» Программа должна вывести количество элементов в очереди.  
•	«clear» Программа должна очистить очередь и вывести «ok».  
•	«min» Программа должна вывести минимум в очереди, не удаляя его из очереди.  
Если во входных данных встречается операция «front», «dequeue» или «min», и при этом очередь пуста, то программа должна вместо числового значения вывести строку «error».
### Формат ввода:
В первой строке входных данных записано единственное число M (1 ≤ M ≤ 2 ⋅ 10<sup>5</sup>) — количество команд. В следующих М строках дано по одной команде из тех, что идут выше.
### Формат вывода:
Для каждой команды выведите одну строчку — результат ее выполнения.
## [K. Минимум на отрезке](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/K.cpp)
Рассмотрим последовательность целых чисел длины N. По ней с шагом 11 двигается "окно" длины K, то есть сначала в "окне" видно первые K чисел, на следующем шаге в "окне" уже будут находиться K чисел, начиная со второго, и так далее до конца последовательности. Требуется для каждого положения "окна" определить минимум в нём.
### Формат ввода:
В первой строке входных данных содержатся два числа N и K (1 ≤ N ≤ 150000, 1 ≤ K ≤ 10000, K ≤ N) -- длины последовательности и "окна", соответственно. На следующей строке находятся N чисел -- сама последовательность.
### Формат вывода:
Выходные данные должны содержать N − K + 1 строк -- минимумы для каждого положения "окна".
## [L. Высота дерева](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/L.cpp)
Реализуйте бинарное дерево поиска для целых чисел. Программа получает на вход последовательность целых чисел и строит из них дерево. Элементы в деревья добавляются в соответствии с результатом поиска их места. Если элемент уже существует в дереве, добавлять его не надо. __Балансировка дерева не производится__.
### Формат ввода:
На вход программа получает последовательность натуральных чисел. Последовательность завершается числом 0, которое означает конец ввода, и добавлять его в дерево не надо.
### Формат вывода:
Выведите единственное число – высоту получившегося дерева.
## [M. Второй максимум](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/M.cpp)
Постройте бинарное дерево поиска и выведите второй по величине элемент в построенном дереве. Гарантируется, что такой найдется.
### Формат ввода:
Дана последовательность целых чисел, оканчивающаяся нулем. Сам ноль в последовательность не входит.
### Формат вывода:
Выведите ответ на задачу.
## [N. Вывод листьев](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/N.cpp)
Реализуйте бинарное дерево поиска для целых чисел. Программа получает на вход последовательность целых чисел и строит из них дерево. Элементы в дерево добавляются последовательно в соответствии с их вводом. Если элемент уже существует в дереве, добавлять его не надо. __Балансировка дерева не производится__.  
Для полученного дерева выведите список всех листьев (вершин, не имеющих потомков) в порядке возрастания.
### Формат ввода:
На вход программа получает последовательность целых чисел через пробел. В последовательности отсутствует число 0, а завершается она числом 0, которое означает конец ввода, и добавлять его в дерево не надо.  
Количество элементов не превосходит 10<sup>9</sup>
### Формат вывода:
Выведите ответ на задачу.
## [O. Вывод развилок](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/O.cpp)
Для полученного дерева выведите список всех вершин, имеющих по два ребёнка, в порядке возрастания.
### Формат ввода:
Вводится последовательность целых чисел, оканчивающаяся нулем. Сам ноль в последовательность не входит. Постройте по этой последовательности дерево.
### Формат вывода:
Выведите ответ на задачу.
## [P. Следующий (AVL)](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/P.cpp)
Реализуйте структуру данных, которая поддерживает множество S целых чисел, с котором разрешается производить следующие операции:  
•	add(i) — добавить в множество S число i (если он там уже есть, то множество не меняется);  
•	next(i) — вывести минимальный элемент множества, не меньший i. Если искомый элемент в структуре отсутствует, необходимо вывести -1.
### Формат ввода:
Исходно множество S пусто. Первая строка входного файла содержит n — количество операций (1≤ n ≤ 300000). Следующие n строк содержат операции. Каждая операция имеет вид либо «+ i», либо «? i». Операция «? i» задает запрос next(i).  
Если операция «+ i» идет во входном файле в начале или после другой операции «+», то она задает операцию add(i). Если же она идет после запроса «?», и результат этого запроса был y, то выполняется операция add((i + y)10<sup>9</sup>)  
Во всех запросах и операциях добавления параметры лежат в интервале от 0 до 10<sup>9</sup>.
### Формат вывода:
Для каждого запроса выведите одно число — ответ на запрос.
## [Q. Array](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/Q.cpp)
_C-style массивы эффективней в использовании чем массивы в динамической памяти, из-за известного на этапе компиляции фиксированного размера и более эффективного расположения в памяти (стековая/автоматическая память). Однако едва ли C-массивы можно назвать удобными в использовании - они спонтанно приводятся к указателям, их не так просто передать в функцию, не работает привычная операция присваивания и т.д. В этой задаче предлагается написать ООП обертку над C-style массивом, который обладает всеми его преимуществами, нивелируя при этом описанные недостатки._  

__std::array (C++11)__  
Начиная с `C++11` в стандартной библиотеке (заголовочный файл `<array>)` появился шаблонный класс `std::array<T, N>`, параметризованный типом хранимых элементов T и размером N. Этот класс содержит единственное поле типа "массив T из N элементов" и предоставляет методы для удобного доступа к информации (размер, элементы и т.д), а также изменения элементов массива. Класс `std::array` в полной мере обеспечивает функционал обычных массивов, не теряя при этом эффективности. Поэтому в современном C++ принято использовать именно `std::array` вместо `C-style` массивов.  

__Детали реализации__  
Вам необходимо реализовать шаблонный класс `Array` - упрощенный аналог `std::array`. Ваш класс должен быть параметризован типом хранимых элементов, а также размером массива. Как было сказано ранее, этот класс должен иметь ровно одно поле - `C-style` массив требуемого типа и размера. Важным моментом является то, что это поле должно быть публичным! В этом случае, как известно, становится доступна агрегатная инициализация вашего массива:  
`int arr[4]{1, 2, 3}`;  // массив `{1, 2, 3, 0}`  
`Array<int, 4> my_arr{1, 2, 3}`;  // если поле публично, то `{1, 2, 3, 0}`, иначе - CE  

Для корректного прохождения тестов ваш класс должен реализовывать следующие методы (подумайте, какие методы должны быть константными, какие - неконстантными, а какие должны иметь обе версии):  
•	Операция `[]` для доступа к элементу массива по индексу;  
•	Метод `At(size_t idx)`, который обеспечивает безопасный (с проверкой границ) доступ к элементу по индексу. В случае выхода за границы необходимо бросать исключение типа `ArrayOutOfRange`, которое уже написано за вас (см. замечания);  
•	Методы `Front()` и `Back()` для доступа к первому и последнему элементу соответственно;  
•	Метод `Data()`, возвращающий указатель на начало массива;  
•	Методы `Size()` и `Empty()`;  
•	Метод `Fill(const T& value)`, который заполняет массив значениями `value`;  
•	Метод `Swap(Array<T, N>& other)`, обменивающий содержимое массивов одинакового размера.

__Замечания.__  
1.	Проверка устроена таким образом, что требует от вас жесткого следования принятым (выше) сигнатурам и именованиям сущностей (то есть никакие `MyArray`, `__array_`, `back`, `superSolver3000` не пройдут). Если вы реализовали требуемый функционал не полностью или интерфейс отличается от заявленного, в ответ вы получите ошибку компиляции.  
2.	Решение должно состоять из одного файла `array.h` с определением класса.  
3.	В задаче нет скрытых тестов - все тесты публичные (`array_public_test.cpp`).  
4.	"Бросить исключение типа E" значит - написать строку `throw E{}`;. В этот момент выполнение функции прекращается и, если исключение не будет обработано, программа завершится аварийно. Тестирующий код корректно обработает эту ошибку, вам этого делать не нужно.
## [R. StringView](https://github.com/PlatonYadrov/First_semester/tree/main/second_contest/string_view)
_В этом задании вам предстоит реализовать класс, который представляет собой невладеющую обертку над C-style строками, совмещающий в себе их легкость и удобство использования от ООП._  

__std::string_view (C++17)__  
Класс `std::string` (которым пользоваться все еще пока запрещено) в большинстве случаев удобнее в использовании, безопаснее и иногда эффективнее C-style строк. Однако бывают ситуации, в которых использование последних гораздо предпочтительнее. Например, обращение к элементам строки это всегда (ну, или почти всегда) обращение к памяти в куче, что требует некоторых накладных расходов. Также часто приходится заводить константные строки со статическим временем жизни (обозначение допустимых команд принимаемых программой и т.п.) и для каждой из них необходимо вызвать конструктор, выделить память в куче, заполнить... В то время как строковые литералы заводятся в статической области памяти еще до начала выполнения программы. А если глобальный (статический) объект `std::string` бросит исключение при создании? Тогда его нельзя будет обработать и программа аварийно завершится, так толком и не начав работать.

Хорошо, давайте в этих ситуациях использовать `const char*`. Но это же снова `strlen`, работающий за линейное время, `strcmp` вместо операторов сравнения, небезопасный доступ к данным...

В `C++17` появился класс `std::string_view`, который является легковесной оберткой над C строками. Все, что он хранит,- это указатель на константную последовательность символов и ее размер. Для доступа и работы с ней используются интуитивно понятные методы без необходимости задумываться о завершающем нулевом символе. Более того, последовательность символов не обязана быть нуль-терминированной, так как размер строки хранится в отдельном поле. Таким образом, мы нивелируем недостатки `const char*`, в полной мере используя его преимущества.  
_Пример:_  
`const char* cstyle = "very_very_long_string_here"`;  // c-style строка  
`std::string s = cstyle`;  // выделение памяти в куче (долго + потенциально небезопасно)  
`std::string_view sv = cstyle`;  // просто сохраняем указатель в поле класса и вычисляем длину  
`std::strlen(cstyle)`;  // всегда O(n)  
`sv.size()`;  // всегда O(1)  

__Детали реализации__  
Идея описана выше. Особенностей реализации нет (как слышится так и пишется).  
Реализуйте класс `StringView` с поддержкой:  
•	Конструктора по умолчанию (`nullptr` строка).  
•	Конструктора от `const char*` (с подсчетом длины). Этот конструктор должен допускать неявные преобразования. Чтобы на это не ругался линтер, добавьте к строке с объявлением комментарий "// NOLINT"  
•	Конструктора от `const char*` и `size_t` (длина передается вторым параметром).  
•	Операции `[]`.  
•	Метода `At` (при выходе за границы бросает исключение `StringViewOutOfRange`, которое написано за вас).  
•	Методов `Front()` и `Back()`, которые возвращают первый и последний символ строки соответственно.  
•	Методов `Size()` и `Length()`, которые возвращают длину строки.  
•	Метод `Empty()` проверяет строку на пустоту.  
•	Метод `Data()` возвращает указатель на начало строки.  
•	Метода `Swap(StringView&)`.  
•	Метода `RemovePrefix(size_t prefix_size)`, который сдвигает начало строки на `prefix_size`.  
•	Метода `RemoveSuffix(size_t suffix_size)`, который сдвигает конец строки на `suffix_size`.  
•	Метода `Substr(size_t pos, size_t count = -1)`, который формирует из вызывающего объекта `StringView` на подстроку с началом `pos` и длины `min(count, Size() - pos)` (если pos выходит за границы, то бросает `StringViewOutOfRange)`.  
__Замечания.__  
1.  [https://en.cppreference.com/w/cpp/string/basic_string_view](https://en.cppreference.com/w/cpp/string/basic_string_view)  
2.	Решение должно состоять из двух файлов: `string_view.h` и `string_view.cpp`  
3.	В задаче нет скрытых тестов - все тесты публичные (`string_view_public_test.cpp`).  
4.	"Бросить исключение типа E" значит - написать строку throw `E{}`;. В этот момент выполнение функции прекращается и, если исключение не будет обработано, программа завершится аварийно. Тестирующий код корректно обработает эту ошибку, вам этого делать не нужно.  
## [U. Восстановление дерева](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/U.cpp)
Дан массив pre-order обхода некоторого бинарного дерева поиска. Восстановите по данной последовательности исходное дерево.
### Формат ввода:
Вводится количество чисел в последовательности (не более 100,000), затем сама последовательность целых чисел.
### Формат вывода:
Выведите массив post-order обхода восстановленного дерева
## [V. Гоблины](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/V.cpp)
Гоблины Мглистых гор очень любях ходить к своим шаманам. Так как гоблинов много, к шаманам часто образуются очень длинные очереди. А поскольку много гоблинов в одном месте быстро образуют шумную толку, которая мешает шаманам проводить сложные медицинские манипуляции, последние решили установить некоторые правила касательно порядка в очереди.  
Обычные гоблины при посещении шаманов должны вставать в конец очереди. Привилегированные же гоблины, знающие особый пароль, встают ровно в ее середину, причем при нечетной длине очереди они встают сразу за центром.  
Так как гоблины также широко известны своим непочтительным отношением ко всяческим правилам и законам, шаманы попросили вас написать программу, которая бы отслеживала порядок гоблинов в очереди.
### Формат ввода:
В первой строке входных данный записано число N(1 ≤N ≤ 10<sup>5</sup>) — количество запросов к программе. Следующие N строк содержат описание запросов в формате:  
•	«+ i» — гоблин с номером i(1 ≤ i ≤ N) встает в конец очереди;  
•	«* i» — привилегированный гоблин с номером i встает в середину очереди;  
•	«-» — первый гоблин из очереди уходит к шаманам. Гарантируется, что на момент такого запроса очередь не пуста.
### Формат вывода:
Для каждого запроса типа «-» программа должна вывести номер гоблина, который должен зайти к шаманам.
# [Third_contest](https://github.com/PlatonYadrov/First_semester/tree/main/third_contest)
## [A. Rational](https://github.com/PlatonYadrov/First_semester/tree/main/third_contest/rational)
__Условие__  
_В C++ существует множество встроенных типов данных для работы с целочисленной арифметикой и арифметикой над числами с плавающей точкой. Однако при вычислениях над последними возможны ошибки округления, которые могут накапливаться при сложных (состоящих из множества операций) вычислениях. Если при работе с иррациональными числами округлений избежать не получится, то в программах, требующих манипуляций только с рациональными числами, все вычисления можно свести к точной целочисленной арифметике. Именно это вам и предстоит проделать в данном задании._

__Детали реализации__  
Необходимо реализовать класс для работы с рациональными числами Rational.

Рациональное число представляется двумя взаимно простыми целыми числами - числителем и положительным знаменателем. Этот инвариант необходимо поддерживать при выполнении любых операций над объектами класса `Rational`. Публичный интерфейс класса должен включать:

* Конструктор по умолчанию, который инициализирует число нулем;  
* Неявный конструктор преобразования от целых чисел (должен работать следующий код `Rational x = 5`;). Не забудьте добавить комментарий `// NOLINT` (см. замечания);  
* Конструктор от двух целых чисел (числитель и знаменатель). При этом не гарантируется, что числа взаимно простые и ненулевые (об этом далее);  
* Методы `GetNumerator()` и `GetDenominator()`, возвращающие числитель и знаменатель соответственно;  
* Методы `SetNumerator(int)` и `SetDenominator(int)`, устанавливающие числитель и знаменатель в требуемые значения;  
* Бинарные арифметические операции (`+, -, /, *`) и их присваивающие версии (`+=, -=, /=, *=`);  
* Унарные операции (`+, -`), а также префиксные и постфиксные инкременты и декременты (`++, --`);  
* Операции сравнения;  
* Операции ввода из потока и вывода в поток (`>>, <<`);

При выводе числа в поток необходимо выводить его в виде несократимой дроби в формате `<числитель>/<знаменатель>` либо `<числитель>`, если знаменатель равен 1. Ввод осуществляется в том же формате (но дробь на входе необязательно несократима).  

Пример:  
`Rational x = 5`;        // дробь 5/1  
`std::cout << x`;        // вывод: 5  
`x.SetDenominator(15)`;  // дробь 1/3 (5/15 сократилась)  
`std::cout << x`;        // вывод: 1/3  
`std::cin >> x`;         // ввод: 14/-6, дробь: -7/3 (общий множитель 2; знаменатель > 0)  

__Деление на 0__  
При делении на 0 (в операции деления или при установке знаменателя в 0) программа должна сообщать об ошибке. Для этих целей в `C++` есть механизм исключений. Исключение - объект некоторого класса, который унаследован от стандартного класса ошибки библиотеки `C++`. Если не все ясно сейчас, то это ok, если не все понятно перед зачетом или экзаменом - у вас проблемы.  

Класс ошибки `RationalDivisionByZero` написан за вас, вам лишь требуется в момент, когда происходит деление на ноль, сообщить об ошибке с помощью строки: `throw RationalDivisionByZero{}`;

__Замечания.__
1.	Решение должно состоять из файлов `rational.h` (объявления) и `rational.cpp` (определения). Если для решения вам требуются другие компилируемые файлы с реализацией, их стоит добавить в переменную `RATIONAL_SRC` в файле `CMakeLists.txt`.  
2.	Хорошей идеей будет вынести логику сокращения дроби в отдельный метод.  
3.	`std::gcd`.  
4.	Гарантируется, что числитель и знаменатель в любой момент помещаются в `int32_t`.  
5.	Кодстайл запрещает неявные конструкторы преобразования (и правильно делает), но в этой задаче неявное преобразование из целых чисел в рациональное вполне осмысленно. Чтобы чекер проигнорировал проверку строки с объявлением такого конструктора, добавьте комментарий // NOLINT к этой строке.  
6.	В задаче есть открытые и закрытые тесты. Перед отправкой решения проверяйте его на открытых тестах (чуда не будет, если есть ошибка в публичных тестах, то она проявится и на более сложных приватных).
## [B. Matrix](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/B.cpp)
__Условие__  
_В этом задании вам необходимо реализовать шаблонный класс для работы с матрицами фиксированного размера. Последнее означает, что размеры матрицы должны передаваться в виде шаблонных параметров-целых чисел (non-type template parameters), и для конкретного объекта не могут быть изменены в течении работы программы. С одной стороны, это накладывает ограничения - размер матриц должен быть жестко задан на этапе компиляции и пользователь не имеет возможности его менять. Кроме того, изменения параметров матриц будут требовать повторной компиляции исходного кода, использующего эти матрицы. С другой стороны, так как размеры матрицы - константы времени компиляции, мы имеем возможность использовать нединамические массивы (что заметно ускоряет работу с матрицами), компилятор имеет больше возможностей для оптимизации кода, а неправильная работа с матрицами (умножение матриц неподходящих размеров, обращение неквадратных матриц и т.п.) будет детектироваться еще на этапе сборки программы, а не во время исполнения._  

__Детали реализации__  
Требуется реализовать шаблонный класс `Matrix`, принимающий в качестве шаблонных параметров тип хранимых элементов, число строк матрицы и число столбцов. Так как шаблонные параметры - это константы времени компиляции, элементы матрицы можно хранить в двумерном `C-style` массиве (`std::array` в этом задании пока запрещен). Это поле-массив должно быть публичным для корректной работы агрегатной инициализации.  
Для работы с матрицей предлагается реализовать следующие методы:  
•	`RowsNumber()` и `ColumnsNumber()`, возвращающие число строк и столбцов соответственно;  
•	Операция `()` ("круглые скобки") для доступа к элементам матрицы и возможности их изменения (подумайте, почему не `[]`);  
•	Метод `At`, аналогичный предыдущему пункту, но бросающий исключение `MatrixOutOfRange` в случае выхода за границы матрицы;  
•	Функцию `GetTransposed(matrix)`, возвращающую транспонированную версию переданной матрицы;  
•	Операции сложения, вычитания умножения матриц и их присваивающие версии. Обратите внимание, что эти операции применимы не к любым парам матриц!;  
•	Операции умножения и деления на число (слева и справа), а также их присваивающие версии;  
•	Операции сравнения на равенство и неравенство двух матриц одинакового размера;  
•	Операции ввода из потока и вывода в поток.

__Пример:__  
`Matrix<int, 2, 3> a{{1, 2, 3}, {4, 5, 6}}`;  
`Matrix<int, 3, 2> b = GetTransposed(a)`;  
`// a + b`      CE  
`a + a`;     // Ok  
// `a * a`      CE   
`a * b`;     // Ok  
// `a *= b`  // CE - в матрицу a нельзя присвоить матрицу другого размера  
`b *= Matrix<int, 2, 2>{1, 2, 3, 4}`; // Ok  

`std::cout << a;`  
`1 2 3`  
`4 5 6`  

__Замечания.__  
1.	Решение должно состоять из одного файла `matrix.h`  
2.	В задаче есть открытые и закрытые тесты. Перед отправкой решения проверяйте его на открытых тестах (чуда не будет, если есть ошибка в публичных тестах, то она проявится и на более сложных приватных).  
3.	Помните о константных и неконстантных методах  
4.	"Бросить исключение типа E" значит - написать строку `throw E{}`;. В этот момент выполнение функции прекращается и, если исключение не будет обработано, программа завершится аварийно. Тестирующий код корректно обработает эту ошибку, вам этого делать не нужно.  
5.	Методы этого и дополнительного задания (ниже) необязательно реализовывать наиболее эффективным способом. В первую очередь проверяется правильность реализации.  
## [C. Стандарты Обучения Волшебству](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/C.cpp)
Близнецы Уизли могли стать легендами Хогвартса по целому множеству причин. Тем не менее среди них была одна самая главная. Азарт, с которым близнецы подходили к своим задумкам, можно было сравнить только с таким же презрением к организации академического процесса.  
В свой последний учебный год братья решили вдвоем выполнить план всех учебных кафедр по оценкам "Отвратительно" и "Тролль" (эта отметка означает, что студент по умственному развитию тупой, как тролль). Всего Фреду (или Джорджу) требуется сдать N экзаменов. Определите количество возможных вариантов сдать сессию, при которых никакие два "Тролля" не были получены подряд (экзамены сдаются последовательно).
### Формат ввода:
На вход программы поступает целое число N (1 ≤ N ≤ 90).
### Формат вывода:
Выведите количество искомых вариантов.
## [D. Специалист по волшебному зельеварению](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/D.cpp)
С преподавательской точки зрения Школа Чародейства и Волшебства походит на компактный ад, сжавшийся до пределов учительской. Младшекурсники гоняются по коридорам от Пивза и за Пивзом, старшекурсники экспериментируют со сливочным пивом, Гриффиндор буянит, Слизерин плетет интриги, а Когтевран разбирается, как уничтожить половину планеты. Островком спокойствия остается только кабинет зельеварения, где профессор Снейп уничтожает самооценку очередного набора первокурсников. В этот раз молодым волшебникам предстоит разобраться с зельем Амортенции. Как известно, ингредиенты для любого зелья делятся на три вида --- особо опасные (тип A), неопасные (тип B) и абсолютно точно не опасные (типC). Для превращения любого зелья во взрывоопасное, достаточно добавить подряд не менее двух ингредиентов типа A. Зелье считается безопасным, если оно не является взрывоопасным. Для заданного количества ингредиентов N определить число безопасных способов приготовления зелья.
### Формат ввода:
Одно число 1 ≤ N ≤ 20.
### Формат вывода:
Одно число --- количество безопасных вариантов приготовления зелья.
## [E. Министерский эдикт](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/E.cpp)
Существует точка зрения, по которой большая часть кабинетов Министерства Магии занимается только тем, что помогает невероятному количеству людей тихонечко поспать. Словно в подтверждение этому, по новому эдикту все мобильные номера сотрудников министерства, должны набираться на кнопочном телефоне ходом коня. Например, ходом коня набирается телефон 167-29-43. При этом телефонный номер не может начинаться ни с цифры 0, ни с цифры 8.  
Клавиатура телефона приведена ниже:  
7 8 9  
4 5 6  
1 2 3  
0  
Напишите программу, определяющую количество телефонных номеров длины N, набираемых ходом коня.
### Формат ввода:
Одно число 1 ≤ N ≤ 20.
### Формат вывода:
Выведите искомое количество телефонных номеров.
## [F. Летающие метлы и аристотелевская физика](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/F.cpp)
Летающую метлу придумали в период, который маглы называют Тёмными веками. Считается, что изобрела её легендарная ведьма по имени Селестрия Релево, которая якобы приходилась пра-правнучкой Мерлину.  
Селестрия Релево, или кто там на самом деле придумал все эти заклинания для зачаровывания мётел, ни черта не знала о ньютоновской механике.  
Поэтому мётлы летают согласно аристотелевской физике.  
Они летят туда, куда их направляют.  
Осознавая это, Министерство ввело ограничения на возможные маневры наездников, чтобы их траектории при движении по сложным перекресткам не пересекались. Принципы просты --- все зависит от того, по какой полосе оператор метлы подлетел к перекрестку. Для этого используется знак "движение по полосам", на рисунке приведен пример такого знака, установленного перед одним из перекрестков в Хогсмиде.  

Рассмотрим дорогу, подходящую к перекрестку, на котором сходится m дорог. Наездник подлетающий к перекрестку по этой дороге, потенциально может продолжить свое движение в m различных направлениях - обратно по дороге, по которой он приехал, а также по одной из оставшихся m−1 дорог. Пронумеруем возможные направления числами от 1 до m слева направо с точки зрения подъезжающего водителя, номер 1 получит разворот и возврат по дороге, по которой водитель подъезжал к перекрестку, номер 2 - поворот на самую левую из дорог и т. д.

Пусть дорога содержит n полос для движения. Пронумеруем полосы от 1 до n слева направо, самая левая полоса получит номер 1, следующая номер 2 и т. д. Знак "движение по полосам" разрешает каждой из полос движение по некоторым из m возможных направлений. При этом должны выполняться следующие условия:  
•	Если с i-й полосы разрешено движение в a-м направлении, а с j-й полосы - в b-м направлении, причем i < j, то a ≤ b;  
•	С каждой полосы разрешено движение хотя бы в одном направлении;  
•	В каждом направлении разрешено движение хотя бы с одной полосы.  
Штаб традиционной авиации (коротко ШТА) заинтересовался: а сколько различных знаков "движение по полосам" можно установить перед таким перекрестком. Помогите им найти ответ на этот вопрос. 
### Формат ввода:
На вход программы поступают два целых числа: m и n (2 ≤ m ≤ 50,1 ≤ n ≤ 15).
### Формат вывода:
Выведите одно число - количество возможных знаков "движение по полосам", которые можно установить перед перекрестком. 
## [H. Экспериментальный метод Поттера](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/H.cpp)
Отношение магии к законам, таким как закон сохранения энергии, напоминает что-то между гигантским оттопыренным средним пальцем и абсолютно безразличным пожиманием плечами. Агуаменти создает воду из ничего — во всяком случае, так считается. Никто не знает озера, в котором уровень воды понижался бы всякий раз при использовании этого заклинания. Простого заклинания уровня пятого курса, довольно посредственного на взгляд волшебников, поскольку создание стакана с водой не кажется им чем-то удивительным. И плевать они хотят на то, что масса должна сохраняться, или что создание грамма вещества эквивалентно созданию 90 000 000 000 000 джоулей энергии.  
Гарри Джеймс Поттер-Верес-Эванс ставит эксперимент по измерению массы создаваемой заклинанием воды. Его набор содержит n гирь массой 1 грамм, 4 грамма, 16 грамм, …, 4<sup>n−1</sup> грамм и две чаши весов. Чтобы взвесить стакан воды, надо положить его на левую чашу весов и поставить некоторые гири на левую и правую чашу для достижения равновесия. Требуется найти, сколько целых масс в диапазоне [1; m] возможно измерить, используя весы и данный набор гирь.
### Формат ввода:
В единственной строке содержаться 2 целых числа m и n (1 ≤ n, m ≤ 10<sup>9</sup>)
### Формат вывода:
Выведите одно число - количество масс, которые можно измерить с помощью этих гирь.
## [I. Волшебники называют это "Магические счеты"](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/I.cpp)
Большинство магловских приборов не работают в Хогвартсе, а те, что работают --- безжалостно сбоят. Единственнный калькулятор в школе волшебства, привезенный почти полвека назад кем-то из учеников, может выполнять только три операции:  
1.	Прибавить к числу X единицу;  
2.	Умножить число X на 2;  
3.	Умножить число X на 3.

Определите кратчайшую последовательность операций, необходимую для получения из числа 1 заданного числа N.
### Формат ввода:
Программа получает на вход одно число N, не превосходящее 10<sup>6</sup>
### Формат вывода:
Требуется вывести одно число: наименьшее количество искомых операций.
## [J. Мандрагоры](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/J.cpp)
В марте несколько мандрагор закатили в теплице номер три шумную, безобразную вечеринку, чрезвычайно порадовав профессора Стебль.  
— Раз они стали лазать друг к другу в горшки, значит, они совсем созрели, — объяснила она Гарри. — И скоро мы сможем вернуть к жизни тех несчастных в больничном крыле. Но пока нужно соединить некоторые пары мандрагор дьявольскими силками так, чтобы к каждой мандрагоре были привязаны хотя бы одни силки. Постарайся, чтобы суммарная длина всех силков была минимальна.  
Мандрагоры высажены в один ряд и любые две из них можно соединить силками.
### Формат ввода:
В первой строке входных данных записано число N — количество мандагор (2 ≤ N ≤ 100). В следующей строке заданы N чисел — координаты всех мандрагор (неотрицательные целые числа, не превосходящие 10000).
### Формат вывода:
Выведите единственное число — минимальную суммарную длину всех силков.
## [K. Гарри Поттер и НОП](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/K.cpp)
Даны две последовательности, требуется найти и вывести их наибольшую общую подпоследовательность.
### Формат ввода:
В первой строке входных данных содержится число N --- длина первой последовательности (1 ≤ N ≤ 1000). Во второй строке заданы члены первой последовательности (через пробел) --- целые числа, не превосходящие 10000 по модулю.  
В третьей строке записано число M --- длина второй последовательности (1 ≤ M ≤ 1000). В четвертой строке задаются члены второй последовательности (через пробел) --- целые числа, не превосходящие 10000 по модулю.
### Формат вывода:
Требуется вывести наибольшую общую подпоследовательность данных последовательностей, через пробел.
## [L. Гарри Поттер и НВП](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/L.cpp)
Дана последовательность, требуется найти её наибольшую возрастающую подпоследовательность.
### Формат ввода:
В первой строке входных данных задано число N - длина последовательности (1 ≤ N ≤ 1000). Во второй строке задается сама последовательность (разделитель --- пробел). Элементы последовательности - целые числа, не превосходящие 10000 по модулю.
### Формат вывода:
Требуется вывести наибольшую возрастающую подпоследовательность данной последовательности. Если таких подпоследовательностей несколько, необходимо вывести одну (любую) из них.
## [M. Ежедневный пророк](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/M.cpp)
Рита Скитер берет очередное интервью для "Ежедневного пророка". Как и у любого другого интервью журналистки, содержание получившейся статьи будет зависеть не от того, что хотел сказать собеседник, а от того, что напишет Прытко Пишущее Перо. Разберемся с процессом написания статьи, запатентованным репортершей:  
Допустим, вам дана текстовая строка. Прытко Пишущее Перо заточено на следующие операции:  
•	Замена одного символ строки на другой.  
•	Удаление одного произвольного символа.  
•	Вставка произвольного символа в произвольное место строки.  
Первая операция из строки «БОК» делает строку «БУК», вторая  — строку «ОК», третья  — строку «БОКС». Минимальное количество таких операций, при помощи которых можно из одной строки получить другую, называется стоимостью редактирования или расстоянием Левенштейна. Определите расстояние Левенштейна для двух данных строк.
### Формат ввода:
Программа получает на вход две строки, длина каждой из которых не превосходит 5000 символов, строки состоят только из заглавных латинских букв.
### Формат вывода:
Требуется вывести одно число — расстояние Левенштейна для данных строк.
## [N. Гарри Поттер и число возрастающих подпоследовательностей](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/N.cpp)
Задана последовательность целых чисел. Найдите количество ее возрастающих подпоследовательностей.
### Формат ввода:
Первая строка входного файла содержит длину последовательности n (1 ≤ n ≤ 100), а вторая --- ее элементы (натуральные числа, меньшие 5000).
### Формат вывода:
Выведите количество возрастающих подпоследовательностей по модулю 10<sup>6</sup>
## [O. Особенности волшебного багажа](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/O.cpp)
Хогвартские школьные чемоданы, как и большинство волшебного багажа, стандартно выпускаются со встроенными увеличивающими или расширяющими чарами. Это довольно сложные чары, позволяющие в небольшом по объёму предмете или маленьком помещении держать множество вещей. Иными словами, вещь внутри становится намного больше, чем снаружи. Но у всего есть предел. Даже сильнейшие чары не позволят вам поднять вес больший M.  
Юному волшебнику перед началом учебного года необходимо собрать уйму вещей. Самый общий список включает N предметов массой m<sub>1</sub>,…, m<sub>N</sub> и стоимостью c<sub>1</sub>,…,c<sub>N</sub> соответственно. Определите имеющий наибольшую стоимость набор предметов, который можно унести в хогвартском чемодане максимальной вместимости.
### Формат ввода:
В первой строке вводится натуральное число N, не превышающее 100 и натуральное число M, не превышающее 10000.  
Во второй строке вводятся N натуральных чисел m<sub>i</sub>, не превышающих 100.  
В третьей строке вводятся N натуральных чисел c<sub>i</sub>, не превышающих 100.  
### Формат вывода:
Выведите номера предметов (числа от 1 до N), которые войдут в чемодан наибольшей стоимости.
## [P. Гарри Поттер и быстрая НВП](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/P.cpp)
Дана последовательность, требуется найти длину её НВП.
### Формат ввода:
В первой строке входных данных задано число N --- длина последовательности (1 ≤ N ≤ 10<sub>5</sub>). Во второй строке задается сама последовательность (разделитель --- пробел). Элементы последовательности --- целые числа, не превосходящие 100000 по модулю.
### Формат вывода:
Длина НВП.
## [Q. Хогвартские коридоры. Первые дни](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/Q.cpp)
К концу первого месяца в Хогвартсе большинство учеников понимает, что:  
1) картина Эшера по сравнению с лестницами Хогвартса — ещё цветочки,  
2) если ты хочешь, чтобы тебя нашли, нужно переходить от кабинета к кабинету, каждый раз выбирая тот, чей номер больше остальных. И так до тех пор, пока не окажешься в ситуации, что дальнейший переход совершить невозможно (так как останешься на месте при попытке перейти дальше). Причем, если комнаты на этаже расположены в виде прямоугольника X × Y (где X --- количество рядов), то нужно придерживать определенных правил обхода, а именно, стоя у комнаты с координатами (0, 0) (то есть около левой в нулевом ряду), можно перемещаться только к комнатам с координатами (a, b), где a ∈ [0, h), b ∈ [0, w). Или, например, будучи рядом с комнатой (i, j), можно перейти только к комнатам с координатами (a, b), где a ∈ [i, i + h), b ∈ [j, j + w).

Необходимо вывести координаты кабинета, к которому в конечном счете выйдет первокурсник. Все аудитории имеют разные номера.
### Формат ввода:
В первой строке идут два целых числа X, Y - размеры этажа (1 ≤ X ⋅ Y ≤ 10<sup>6</sup>).  
Во второй строке идут два целых числа h, w - правила обхода (1 ≤ h ≤ X, 1 ≤ w ≤ Y).  
Далее идут X строк по Y целых чисел s<sub>ij</sub> - номера аудиторий. (0 ≤ s<sub>ij</sub> ≤ 10<sup>9</sup>). Гарантируется, что все s<sub>ij</sub> различны.  
Оси координат заданы так, что кабинет с координатами (0, 0) идет первым в первой строке описания номеров комнат, а кабинет с координатами (0, Y − 1) идет последним в той же строке.
### Формат вывода:
В ответе необходимо вывести два числа через пробел - координаты кабинета, у которого остановится юный волшебник в результате таких переходов.
## [S. Сплетни Полумны Лавгуд](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/S.cpp)
Падма Патил и Полумна Лавгуд придумали очередной способ кодировать сообщения со сплетнями. Патил посылает Лавгуд строку S, а Лавгуд ищет ключ, чтобы расшифровать сплетню. Ключ - натуральное число, равное минимальному количеству символов, которое надо удалить из S, чтобы получился палиндром. Модуль дешифровки уже написан, а вот помочь Лавгуд с поиском ключа по сообщению - ваша задача.
### Формат ввода:
Дана строка S из строчных латинских букв, ее длина не превышает 10<sup>4</sup>.
### Формат вывода:
Выведите единственное число --- ключ для дешифровки сообщения.
## [U. Семейный бизнес Уизли](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/U.cpp)
Мать близнецов Уизли в очередной раз конфискует весь товар начинающих предпринимателей, ставя маленький семейный бизнес под угрозу банкроства. Теперь близнецам придется все лето придется потратить на подработки, чтобы вернуть хотя бы часть стартового капитала. Например, заняться покраской шахматных досок. К несчастью, их понимание маглов далеко от идеала (помним, что такие как Артур Уизли – единичны, но даже они не в состоянии понять, что делать со штекером), поэтому доски имеют форму прямоугольника N × M, каждую клетку которого можно покрасить в черный или белый цвет. Т.к. занятие монотонной работой никого не радует, близнецы выработали два правила -- во-первых, все доски должны быть уникальны, а во-вторых, нигде в них не должно встречаться квадрата 2 × 2, покрашенного полностью в один цвет. Сколько всего наборов шахмат они смогут изготовить?
### Формат ввода:
Вводятся два положительных целых числа N и M (1 ≤ N ⋅ M ≤ 30).
### Формат вывода:
Выведите единственное число -- количество различных симпатичных узоров, которые можно выложить во дворе размера N х M. Узоры, получающиеся друг из друга сдвигом, поворотом или отражением, считаются различными.
## [V. Специфика высшего магического образования](https://github.com/PlatonYadrov/First_semester/blob/main/second_contest/V.cpp)
Как известно, матричное умножение ассоциативно, то есть результат умножения не зависит от порядка выполнения операций: A⋅(B⋅C)=(A⋅B)⋅C. Однако с точки зрения вычислительной сложности ситуация абсолютно иная. Например, если размеры матриц A, B, C равны 1 × 2, 2 × 3, 3 × 4 соответственно, то умножение первым способом требует 32 операции умножения чисел, а вторым - 18 (в предположении, что используется наивный алгоритм перемножения двух матриц).
Напишите программу, вычисляющую минимальное количество операций умножения чисел в произведении A<sub>1</sub> ⋅ A<sub>2</sub> ⋅...⋅ A<sub>n-1</sub>.
### Формат ввода:
В первой строке подается число n (3 ≤ n ≤ 200).  
На следующей строке идут n положительных чисел k<sub>1</sub>, k<sub>2</sub>, …, k<sub>n</sub> ≤ n - последовательность размеров матриц (матрица A<sub>1</sub> имеет размер k<sub>1</sub> × k<sub>2</sub>, A<sub>2</sub> --- k<sub>2</sub> × k<sub>3</sub>, ..., A<sub>n-1</sub> --- k<sub>n-1</sub> × k<sub>n</sub>).
### Формат вывода:
Выведите одно число - ответ на задачу
